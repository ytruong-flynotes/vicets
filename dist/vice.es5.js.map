{"version":3,"file":"vice.es5.js","sources":["../src/problems.ts","../src/helpers.ts","../src/impl/util/types.ts","../src/impl/core.ts","../src/impl/util/maps.ts","../src/jsonSchema.ts","../src/impl/associative/behaviour.ts","../src/impl/associative/associative.ts","../src/impl/associative/map.ts","../src/impl/util/magic.ts","../src/impl/associative/obj.ts","../src/impl/associative/objof.ts","../src/impl/associative/tuple.ts","../src/impl/associative/wrap.ts","../src/impl/util/iterables.ts","../src/impl/discriminated_union/find_discriminators.ts","../src/impl/discriminated_union/index.ts","../src/impl/arrayof.ts","../src/impl/bool.ts","../src/impl/util/json.ts","../src/impl/defaultValue.ts","../src/impl/deferred.ts","../src/impl/e164PhoneNumber.ts","../src/impl/util/analyseEnum.ts","../src/impl/enumvalue.ts","../src/impl/eq.ts","../src/impl/isin.ts","../src/impl/isinstance.ts","../src/impl/util/dates.ts","../src/impl/isoUtcDateTime.ts","../src/impl/lens.ts","../src/impl/lookup.ts","../src/impl/number.ts","../src/impl/override.ts","../src/impl/regexp.ts","../src/impl/select.ts","../src/impl/setof.ts","../src/impl/unique.ts","../src/impl/url.ts","../src/impl/uuid.ts","../src/hasschema.ts","../src/schematize.ts","../src/ValidationError.ts","../src/mocha.ts","../src/impl/conditional.ts","../src/data.ts","../src/impl/util/functions.ts","../src/schemas.ts"],"sourcesContent":["export type Path = any[];\n\nexport class Problem {\n  constructor(readonly path: Path, readonly message: string) {\n  }\n\n  prefixPath(p: Path): Problem {\n    return new Problem([...p, ...this.path], this.message);\n  }\n\n  toString(): string {\n    return `[${this.path.join(' -> ').trimRight()}] : ${this.message}`\n  }\n}\n\nexport class Problems {\n  constructor(readonly problems: Problem[]) {\n  }\n\n  get length(): number {\n    return this.problems.length;\n  }\n\n  prefixPath(p: Path): Problems {\n    return new Problems(this.problems.map(e => e.prefixPath(p)));\n\n  }\n\n  merge(...ps: Problems[]): Problems {\n    return ps.reduce((acc: Problems, next: Problems) => acc.append(...next.problems), this);\n\n  }\n\n  append(...ps: Problem[]): Problems {\n    return new Problems([...this.problems, ...ps]);\n\n  }\n\n  toString(): string {\n    return this.problems.map(e => e.toString()).join('\\r\\n')\n  }\n}\n\nexport function isError(x: ValidationResult<any>): x is Problems {\n  return x != null && x instanceof Problems;\n}\n\nexport function isSuccess<T>(x: ValidationResult<T>): x is T {\n  return !isError(x);\n}\n\nexport function problem(message: string, path: Path = []) {\n  return new Problem(path, message);\n}\n\nexport function problems(...ps: Problem[]): Problems {\n  return new Problems(ps);\n}\n\nexport function failure(message: string, path: Path = []): Problems {\n  return problems(problem(message, path)) as Problems;\n}\n\nexport interface ValidationErrorOpts {\n  readonly message: string,\n  readonly leakActualValuesInError: boolean,\n}\n\nexport type ValidationResult<T> = Problems | T;","import {Behaviour, Problems, Schema, usingBehaviour, ValidationError, ValidationResult} from \"./impl\";\n\nexport interface ValidationOpts extends Behaviour {\n  message: string;\n}\n\nexport function validate<IN, OUT>(\n  schema: Schema<IN, OUT>,\n  value: IN,\n  opts: Partial<ValidationOpts> = {})\n  : OUT {\n\n  const conformed = conform(schema, value, opts);\n  if (conformed instanceof Problems) {\n    throw new ValidationError(value, conformed, opts);\n  }\n  return conformed;\n}\n\nexport function conform<IN, OUT>(\n  schema: Schema<IN, OUT>,\n  value: IN,\n  opts: Partial<ValidationOpts> = {})\n  : ValidationResult<OUT> {\n\n  if (!schema)\n    throw new Error(\"No schema provided\");\n\n  return usingBehaviour(opts, () => schema.conform(value));\n}\n\n","export type PrimitiveValue = string | number | boolean;\n\nexport function isPrimitive(value: any): boolean {\n  return (typeof value !== 'object' && typeof value !== 'function') || value === null\n}\n\nexport function unsafeCast<T>(x: any): T {\n  return x as T;\n}\n\nexport function typeDescription(x: any): string {\n  if (x === null)\n    return 'null';\n\n  let t = typeof x;\n  if (t !== 'object') return t;\n\n  const p = Object.getPrototypeOf(x);\n  if (p !== Object.prototype)\n    return p.constructor.name;\n\n  return t\n}\n\nexport type Constructor<T = any> = new(...args: any[]) => T ;","import {conform} from \"../helpers\";\nimport {failure, isError, isSuccess, Problems, ValidationResult} from \"../problems\";\nimport {Schema} from \"../schema\";\nimport {subSchemaJson} from \"./\";\nimport {typeDescription} from \"./util/types\";\n\nexport abstract class BaseSchema<IN = any, OUT = any> implements Schema<IN, OUT> {\n\n  or<NEWOUT>(s: Schema<IN, NEWOUT>): Schema<IN, OUT | NEWOUT> {\n    return new OrSchema<IN, OUT | NEWOUT>([this, s]);\n  }\n\n  and<NEWOUT>(s: Schema<OUT, NEWOUT>): Schema<IN, NEWOUT> {\n    return new AndSchema([this, s])\n  }\n\n  __<FAKED extends OUT>(): FAKED {\n    return this as any as FAKED;\n  }\n\n  abstract conform(value: IN): ValidationResult<OUT>;\n\n  abstract toJSON(toJson?: (s: Schema) => any): any;\n\n\n}\n\nexport class AndSchema<IN, OUT> extends BaseSchema<IN, OUT> {\n  constructor(private readonly subSchemas: Schema[]) {\n    super();\n  }\n\n  conform(value: IN): ValidationResult<OUT> {\n    return this.subSchemas.reduce((result, schema) => {\n      if (isError(result))\n        return result;\n      return conform(schema, result);\n    }, value);\n  }\n\n  and<NEWOUT>(s: Schema<OUT, NEWOUT>): Schema<IN, NEWOUT> {\n    return s instanceof AndSchema\n      ? new AndSchema([...this.subSchemas, ...s.subSchemas])\n      : new AndSchema([...this.subSchemas, s])\n  }\n\n  toJSON(toJson?: (s: Schema) => any) {\n    return {\n      allOf: subSchemaJson(this.subSchemas,toJson)\n    };\n  }\n}\n\nexport class OrSchema<IN, OUT> extends BaseSchema<IN, OUT> {\n  constructor(private readonly subSchemas: Schema<IN, OUT>[]) {\n    super();\n  }\n\n  conform(value: IN): ValidationResult<OUT> {\n    const failures: Problems[] = [];\n    for (const s of this.subSchemas) {\n      const result = s.conform(value);\n\n      if (isSuccess(result)) return result;\n\n      failures.push(result as Problems);\n    }\n    return failures.reduce((a: Problems | null, ps: Problems) => a ? a.merge(ps) : ps);\n  }\n\n\n  or<NEWOUT>(s: Schema<IN, NEWOUT>): Schema<IN, OUT | NEWOUT> {\n    return s instanceof OrSchema\n      ? new OrSchema<IN, OUT | NEWOUT>([...this.subSchemas, ...s.subSchemas])\n      : new OrSchema<IN, OUT | NEWOUT>([...this.subSchemas, s])\n  }\n\n  toJSON(toJson?: (s: Schema) => any) {\n    return {\n      anyOf: subSchemaJson(this.subSchemas, toJson)\n    }\n  }\n\n}\n\nexport abstract class BaseStringSchema extends BaseSchema<any, string> {\n  conform(value: any): ValidationResult<string> {\n    if (typeof value === 'string' || value instanceof String)\n      return this.conformString(value as string);\n    return failure(`expected a string but got ${typeDescription(value)}`);\n  }\n\n  abstract conformString(value: string): ValidationResult<string>;\n\n  toJSON(): any {\n    return {type: \"string\"}\n  }\n}\n\nexport class StringSchema extends BaseStringSchema {\n  conformString(value: string): ValidationResult<string> {\n    return value;\n  }\n}\n\n\nexport class DelegatingSchema<IN, OUT> extends BaseSchema<IN, OUT> {\n  constructor(private readonly delegatedConform: (value: IN) => Problems | OUT,\n              public readonly toJSON: () => any = () => {\n                throw new Error('toJSON not implemented')\n              }) {\n    super();\n  }\n\n  conform(value: IN): ValidationResult<OUT> {\n    return this.delegatedConform(value);\n  }\n}\n\nexport function isSchema(value: any): value is Schema {\n  // TODO: probably wrong?\n  return value instanceof BaseSchema;\n}","export function mapKeyValue<K, V, NEWK, NEWV>(f: (k: K, v: V) => [NEWK, NEWV], m: Map<K, V>): Map<NEWK, NEWV> {\n  const result = new Map<NEWK, NEWV>();\n  for (const [k, v] of m.entries()) {\n    const [nk, nv] = f(k, v);\n    result.set(nk, nv);\n  }\n  return result;\n}\n\nexport function mapValues<K, V, NEWV>(f: (v: V) => NEWV, m: Map<K, V>): Map<K, NEWV> {\n  return mapKeyValue((k, v) => [k, f(v)], m);\n}\n\nexport function merge<K, V>(a: Map<K, V>, b: Map<K, V>, conflictFn: (a: V, b: V) => V): Map<K, V> {\n  const result = new Map<K, V>();\n  for (const [k, v] of a.entries()) {\n    result.set(k, v);\n  }\n  for (const [k, v] of b.entries()) {\n    if (result.has(k)) {\n      result.set(k, conflictFn(a.get(k)!, v));\n    }\n    else {\n      result.set(k, v);\n    }\n  }\n  return result;\n}\n\nexport function toMap<K, V>(x: {}): Map<K, V> {\n  const result = new Map<K, V>();\n  for (let [k, v] of Object.entries(x)) {\n    result.set(\n      k as any as K,\n      v as any as V);\n  }\n  return result;\n}","import {DataSchema} from \"./data\";\nimport {isSchema} from \"./impl\";\nimport {merge} from \"./impl/util/maps\";\nimport {Schema, SchemaDefinitions} from \"./schema\";\n\nexport function subSchemaJson(schema: Schema | Schema[], toJson?: (s: Schema) => any): any {\n  toJson = toJson || ((s: Schema) => s.toJSON());\n  return Array.isArray(schema)\n    ? schema.map(toJson)\n    : toJson(schema);\n}\n\nfunction refLookup(defs: SchemaDefinitions, path: string = \"#/definitions\"): Map<Schema, object> {\n  return Object.entries(defs)\n    .reduce((result, [k, schemaOrDefs]) => {\n      const itemPath = `${path}/${k}`;\n      if (isSchema(schemaOrDefs)) {\n        if (schemaOrDefs instanceof DataSchema)\n          schemaOrDefs = schemaOrDefs.subSchema;\n        result.set(schemaOrDefs, {$ref: itemPath});\n        return result;\n      }\n      else {\n        const lookup = refLookup(schemaOrDefs, itemPath);\n        return merge(result, lookup, () => {\n          throw new Error('Should never happen')\n        });\n      }\n\n    }, new Map<Schema, object>());\n\n}\n\nfunction definitionsJson(defs: SchemaDefinitions, toJson: (s: Schema) => any): object {\n  return Object.entries(defs)\n    .reduce((result, [k, schemaOrDefs]) => {\n      if (isSchema(schemaOrDefs))\n        result[k] = schemaOrDefs.toJSON(toJson);\n      else\n        result[k] = definitionsJson(schemaOrDefs, toJson);\n      return result;\n    }, {});\n\n}\n\nexport interface JsonSchemaOpts {\n  id?: string,\n  definitions: SchemaDefinitions;\n}\n\nexport function jsonSchema(opts: JsonSchemaOpts) {\n  const lookup = refLookup(opts.definitions);\n\n  function subschema(schema: Schema): any {\n    if (schema instanceof DataSchema)\n      schema = schema.subSchema;\n    const ref = lookup.get(schema);\n    const result = ref || schema.toJSON(subschema);\n    return result;\n  }\n\n  const definitions = definitionsJson(opts.definitions, subschema);\n\n  return {\n    ...(opts.id && {id: opts.id}),\n    $schema: \"http://json-schema.org/draft-07/schema#\",\n    definitions,\n  };\n}","import {conform} from \"../../helpers\";\nimport {ValidationResult} from \"../../problems\";\nimport {Schema} from \"../../schema\";\nimport {BaseSchema} from \"../core\";\nimport {subSchemaJson} from \"../../jsonSchema\";\n\nexport enum UnexpectedItemBehaviour {\n  DELETE = \"delete\",\n  IGNORE = \"ignore\",\n  PROBLEM = \"problem\"\n}\n\nexport enum MissingItemBehaviour {\n  IGNORE = \"ignore\",\n  PROBLEM = \"problem\"\n}\n\nexport interface Behaviour {\n  readonly unexpected: UnexpectedItemBehaviour;\n  readonly missing: MissingItemBehaviour;\n  readonly leakActualValuesInError: boolean;\n}\n\nlet BEHAVIOUR: Behaviour = {\n  unexpected: UnexpectedItemBehaviour.PROBLEM,\n  missing: MissingItemBehaviour.PROBLEM,\n  leakActualValuesInError: false,\n};\n\nexport function behaviour(): Behaviour {\n  return BEHAVIOUR;\n}\n\nexport function usingBehaviour<T>(behaviour: Partial<Behaviour>, fn: () => T): T {\n  const old = BEHAVIOUR;\n  BEHAVIOUR = Object.assign({}, old, behaviour);\n  try {\n    return fn();\n  }\n  finally {\n    BEHAVIOUR = old;\n  }\n}\n\nexport class BehaviourSchema<IN, OUT> extends BaseSchema<IN, OUT> {\n  constructor(\n    private readonly behaviour: Partial<Behaviour>,\n    private readonly subSchema: Schema<IN, OUT>) {\n    super();\n  }\n\n  conform(value: IN): ValidationResult<OUT> {\n    return usingBehaviour(\n      this.behaviour,\n      () => conform(this.subSchema, value));\n  }\n\n  toJSON(toJson?: (s: Schema) => any): any {\n    return {\n      ...subSchemaJson(this.subSchema, toJson),\n      additionalProperties: this.behaviour.unexpected !== UnexpectedItemBehaviour.PROBLEM\n    };\n  }\n}","import {\n  BaseSchema,\n  behaviour,\n  failure,\n  isError,\n  MissingItemBehaviour,\n  Problems,\n  Schema,\n  subSchemaJson,\n  UnexpectedItemBehaviour,\n  ValidationResult\n} from \"../\";\n\nexport interface Associative<K, V> {\n  set(k: K, v: V): this;\n\n  delete(k: K): boolean;\n\n  has(k: K): boolean;\n\n  get(k: K): any;\n\n  keys(): Iterable<K>;\n}\n\nexport function conformInPlace<K, V>(thing: Associative<K, V>,\n                                     itemSchemas: Iterable<[K, Schema]>): Problems | undefined {\n\n  let problems = new Problems([]);\n  const unmatchedThingKeys = new Set(thing.keys());\n  const {unexpected, missing} = behaviour();\n  for (const [k, s] of itemSchemas) {\n    const v: ValidationResult<any> = s.conform(thing.get(k));\n\n    if (isError(v) && !thing.has(k)) {\n      if (s[optional] !== true && missing !== MissingItemBehaviour.IGNORE) {\n        problems = problems.merge(failure(\"No value\", [k]));\n      }\n      continue;\n    }\n    unmatchedThingKeys.delete(k);\n\n    if (isError(v)) {\n      problems = problems.merge((v as Problems).prefixPath([k]));\n    } else if (v !== undefined) {\n      thing.set(k, v);\n    }\n  }\n\n  for (const k of unmatchedThingKeys) {\n    switch (unexpected) {\n      case UnexpectedItemBehaviour.IGNORE:\n        break;\n      case UnexpectedItemBehaviour.DELETE:\n        thing.delete(k);\n        break;\n      case UnexpectedItemBehaviour.PROBLEM:\n        problems = problems.merge(failure(\"Unexpected item\", [k]));\n        break;\n      default:\n        throw new Error(`Not implemented- ${unexpected}`);\n    }\n  }\n\n  return problems.length > 0 ? problems : undefined;\n}\n\nexport const optional = Symbol(\"optional\");\n\nexport class TagSchemaAsOptional<IN, OUT> extends BaseSchema<IN, OUT | undefined> {\n  [optional] = true;\n\n  constructor(private readonly subschema: Schema<IN, OUT>) {\n    super();\n  }\n\n  conform(value: IN): Problems | OUT | undefined {\n    return value === undefined ? undefined : this.subschema.conform(value);\n  }\n\n  toJSON(toJson?: (s: Schema) => any): any {\n    return subSchemaJson(this.subschema, toJson)\n  }\n\n}\n\nexport function isOptional(schema: Schema): boolean {\n  return schema[optional];\n}\n\nexport type StrictPatternItem<T> = StrictPattern<T> | Schema<any, T> | T\nexport type StrictPattern<T> = { readonly [K in keyof T]: StrictPatternItem<T[K]> };\n\nexport type PatternItem<T> = Pattern<T> | Schema<any, T> | T\nexport type Pattern<T> = { readonly [K in keyof T]?: PatternItem<T[K]> };","import {\n  Associative,\n  BaseSchema,\n  conformInPlace,\n  failure,\n  ObjectSchema,\n  Schema,\n  subSchemaJson,\n  ValidationResult\n} from \"../\";\nimport {typeDescription} from \"../util/types\";\n\nexport class MapSchema<K, V> extends BaseSchema<any, Map<K, V>> {\n  constructor(private readonly subSchema: ObjectSchema<any>) {\n    super();\n  }\n\n  conform(value: any): ValidationResult<Map<K, V>> {\n    if (value === undefined || value === null)\n      return failure('no value');\n\n    if (!(value instanceof Map || typeof value === 'object'))\n      return failure(`expected a Map or object but got ${typeDescription(value)}`);\n\n    const instance = new Map<K, V>();\n    const kvs = value instanceof Map ? value.entries() : Object.entries(value);\n    for (let [k, v] of kvs) {\n      instance.set(k, v);\n    }\n    const problems = conformInPlace(\n      instance as any as Associative<K, V>,\n      this.subSchema.fieldSchemaArray as any);\n    return problems ? problems : instance;\n  }\n\n  toJSON(toJson?: (s: Schema) => any): any {\n    return subSchemaJson(this.subSchema, toJson);\n  }\n}\n\n\n\n","export function addGetter<T, K extends keyof T>(obj: T, k: K, getter: () => T[K]): T {\n  Object.defineProperty(obj, k, {\n    enumerable: true,\n    configurable: true,\n    get: getter\n  });\n  return obj;\n}\n\nexport type GetterMapper<A, B extends { [K in keyof A]: B[K] }> = <K extends keyof A>(original: A, mapped: B, k: K) => () => B[K];\n\nexport function mapGetters<A, B extends { [K in keyof A]: B[K] }>(original: A, mapper: GetterMapper<A, B>): B {\n  return Object\n    .keys(original)\n    .reduce((mapped, k) => addGetter(mapped, k as any, mapper(original, mapped, k as keyof A)), <B>{});\n}\n\nexport function copyGetters<T>(original: T): T {\n  return Object\n    .keys(original)\n    .reduce((mapped, k) => addGetter(mapped, k as any, () => original[k]),\n      <T>{});\n}\n\nexport function merge<A extends object, B extends object>(a: A, b: B, conflictFn: (a, b) => any): A & B {\n  const result = {};\n  for (const k in a) {\n    result[k.toString()] = a[k];\n  }\n  for (const k in b) {\n    if (k in result) {\n      const kk = k as any as keyof A & keyof B;\n      result[k.toString()] = conflictFn(a[kk], b[kk]);\n    }\n    else {\n      result[k.toString()] = b[k];\n    }\n  }\n  return result as any as A & B;\n}","import {\n  Associative,\n  BaseSchema,\n  conformInPlace,\n  EqualsSchema,\n  failure,\n  isOptional,\n  Pattern,\n  PatternItem,\n  RegExpSchema,\n  Schema,\n  StrictPattern, subSchemaJson,\n  TupleSchema,\n  ValidationResult\n} from \"../\";\nimport {addGetter, copyGetters, merge} from \"../util/magic\";\n\nexport function objectEntries(object: object): [string, Schema][] {\n  const result: [string, Schema][] = [];\n  for (const k of Object.keys(object)) {\n    const s = object[k];\n    if (typeof s['conform'] !== 'function')\n      throw new Error(`Not a schema ${s}`);\n    else\n      result.push([k, s]);\n  }\n  return result;\n}\n\nexport function patternItemToSchema<T>(item: PatternItem<T>): Schema {\n  if (typeof item !== 'object')\n    return new EqualsSchema(item);\n\n  if (item instanceof Array)\n    return new TupleSchema(item.map(v => patternItemToSchema(v)));\n\n  if (typeof item === 'undefined')\n    return new EqualsSchema(undefined);\n\n  if (item === null)\n    return new EqualsSchema(null);\n\n  if (typeof item['conform'] === 'function')\n    return item as Schema;\n\n  return new ObjectSchema(item as Pattern<T>);\n}\n\nexport function patternToSchemas<T extends object>(pattern: Pattern<T>): { [K in keyof T]: Schema<T[K]> } {\n\n  const result = {};\n  for (const k of Object.keys(pattern)) {\n    const s = pattern[k];\n    result[k] = patternItemToSchema(s);\n  }\n  return result as any;\n}\n\nexport class ObjectStrategies implements Associative<string, any> {\n  constructor(public readonly result: any) {\n  }\n\n  set(k: any, v: any): this {\n    addGetter(this.result, k, () => v);\n    return this\n  }\n\n  delete(k: any): boolean {\n    return delete this.result[k];\n  }\n\n  has(k: any): boolean {\n    return k in this.result;\n  }\n\n  get(k: any): any {\n    return this.result[k];\n  }\n\n  keys(): Iterable<string> {\n    return Object.keys(this.result);\n  }\n}\n\nexport class ObjectSchema<T extends object> extends BaseSchema<any, T> {\n  public readonly fieldSchemaArray: [string, Schema][];\n\n  constructor(public readonly pattern: Pattern<T>) {\n    super();\n    this.fieldSchemaArray = objectEntries(patternToSchemas(pattern));\n  }\n\n  conform(value: any): ValidationResult<T> {\n    if (value === undefined || value === null)\n      return failure('no value');\n\n    if (typeof value !== 'object')\n      return failure(`expected an object but got ${typeof value}`);\n\n    const instance = copyGetters(value);\n    return this.conformInPlace(instance) as T;\n  }\n\n  /**\n   * Required to allow @hasSchema to conform 'this'\n   */\n  conformInPlace(instance: {}): ValidationResult<{}> {\n    const problems = conformInPlace(\n      new ObjectStrategies(instance),\n      this.fieldSchemaArray);\n\n    return problems ? problems : instance;\n  }\n\n  intersect<U extends object>(other: ObjectSchema<U>): ObjectSchema<T & U> {\n    const mergedSchemas = merge(this.pattern, other.pattern, (a: Schema, b: Schema) => a.and(b)) as StrictPattern<T & U>;\n    return new ObjectSchema<T & U>(mergedSchemas);\n  }\n\n  toJSON(toJson?: (s: Schema) => any): any {\n    const properties = this.fieldSchemaArray.reduce((result, [k, subSchema]) => {\n      result[k] = subSchemaJson(subSchema,toJson);\n      return result;\n    }, {});\n\n    const required = this.fieldSchemaArray\n      .filter(([k, schema]) => !isOptional(schema))\n      .map(([k]) => k);\n\n    return {\n      type: \"object\",\n      properties: properties,\n      required: required,\n    }\n  }\n}\n\n\n\n","import {BaseSchema, conformInPlace, failure, ObjectStrategies, Schema, subSchemaJson, ValidationResult} from \"../\";\n\nexport class ObjOfSchema<T> extends BaseSchema<any, { [k: string]: T }> {\n  constructor(private readonly valueSchema: Schema<any, T>) {\n    super()\n  }\n\n  conform(value: any): ValidationResult<{ [p: string]: T }> {\n    if (value === undefined || value === null)\n      return failure('no value');\n\n    if (typeof value !== 'object')\n      return failure(`expected an object but got ${typeof value}`);\n\n    const itemSchemas = Object.keys(value).map(k => [k, this.valueSchema] as [string, Schema<any, T>]);\n    const instance = <{ [p: string]: T }>{};\n    Object.assign(instance, value);\n    const problems = conformInPlace(new ObjectStrategies(instance), itemSchemas);\n    return problems ? problems : instance;\n  }\n\n  toJSON(toJson?: (s: Schema) => any): any {\n    return {\n      type: \"object\",\n      patternProperties: {\n        \".*\": subSchemaJson(this.valueSchema, toJson)\n      }\n    }\n  }\n}","import {Associative, BaseSchema, conformInPlace, failure, Schema, subSchemaJson, ValidationResult} from \"../\";\nimport {typeDescription} from \"../util/types\";\n\nexport class TupleStrategies<T extends any[]> implements Associative<number, any> {\n  private readonly deleted: number[] = [];\n\n  constructor(private readonly resultIn: T) {\n\n  }\n\n  get result(): T {\n    return Array.from(this.keys()).filter(n => this.deleted.indexOf(n) < 0).map(n => this.resultIn[n]) as T;\n  }\n\n  set(k: number, v: any): this {\n    this.resultIn[k] = v;\n    return this;\n  }\n\n  has(k: number): boolean {\n    return k < this.resultIn.length;\n  }\n\n  get(k: number): any {\n    return this.resultIn[k];\n  }\n\n  delete(k: number): boolean {\n    if (this.resultIn.length <= k) return false;\n    this.deleted.push(k);\n    return true;\n  }\n\n  keys(): Iterable<number> {\n    return Array(this.resultIn.length).keys();\n  }\n}\n\nexport class TupleSchema<T extends any[]> extends BaseSchema<T> {\n  private readonly itemSchemas: [number, Schema][];\n\n  constructor(schemas: Schema[]) {\n    super();\n    this.itemSchemas = schemas.map((v, i) => [i, v] as [number, Schema]);\n  }\n\n  conform(value: any): ValidationResult<T> {\n    if (value === undefined || value === null)\n      return failure('no value');\n\n    if (!(value instanceof Array))\n      return failure(`expected an array but got ${typeDescription(value)}`);\n\n    const instance = [] as any as T;\n    for (let i = 0; i < value.length; i++) {\n      instance[i] = value[i];\n    }\n    const result = new TupleStrategies(instance);\n    const problems = conformInPlace(result, this.itemSchemas);\n    return problems ? problems : result.result;\n  }\n\n  toJSON(toJson?: (s: Schema) => any): any {\n    return {\n      type: \"array\",\n      items: subSchemaJson(this.itemSchemas.map(([k, v]) => v), toJson)\n    }\n  }\n}","import {Associative, ObjectStrategies, TupleStrategies} from \"../\";\n\nexport function wrapAssociative(actual: any): Associative<any, any> {\n  if (actual instanceof Array)\n    return new TupleStrategies(actual);\n  if (typeof actual === 'object')\n    return new ObjectStrategies(actual);\n  throw new Error(`Not supported: ${typeof actual}`);\n}\n\nexport function empty(actual: any): any {\n  if (actual instanceof Array)\n    return [];\n  if (typeof actual === 'object')\n    return {};\n  throw new Error(`Not supported: ${typeof actual}`);\n}","export function first<T>(coll: Iterable<T>): T | undefined {\n  // noinspection LoopStatementThatDoesntLoopJS\n  for (const v of coll) {\n    return v;\n  }\n}","import {EqualsSchema, Schema, schemaOf} from \"../\";\nimport {first} from \"../util/iterables\";\nimport {mapKeyValue} from \"../util/maps\";\nimport {Constructor, isPrimitive, PrimitiveValue, unsafeCast} from \"../util/types\";\n\nclass CandidateDiscriminators<T extends object> {\n  private readonly constructors: Constructor<T>[] = [];\n  private readonly fields = new Map<keyof T, Map<PrimitiveValue, Constructor<T>[]>>();\n\n  constructor(ctors: Constructor<T>[]) {\n    this.constructors = [...ctors];\n    for (const ctor of this.constructors) {\n      for (const [fieldName, value] of CandidateDiscriminators.fieldsWithPrimitiveEquals(ctor)) {\n        const result = this.fields.get(fieldName) || new Map();\n        result.set(value, (result.get(value) || []).concat([ctor]));\n        this.fields.set(fieldName, result)\n      }\n    }\n  }\n\n  private static fieldsWithPrimitiveEquals<T extends object>(ctor: Constructor<T>): [keyof T, PrimitiveValue][] {\n    return CandidateDiscriminators.fieldSchemas(ctor)\n      .map(([field, schema]) => schema instanceof EqualsSchema && isPrimitive(schema.expected) ? [field, schema.expected] : undefined)\n      .filter((x) => x)\n      .map((x) => unsafeCast(x))\n  }\n\n  private static fieldSchemas<T extends object>(ctor: Constructor<T>): [string, Schema<any, any>][] {\n    return schemaOf(ctor).fieldSchemaArray;\n  }\n\n  keys(): IterableIterator<keyof T> {\n    return this.fields.keys();\n  }\n\n  get(field: keyof T): Map<PrimitiveValue, Constructor<T>[]> | undefined {\n    return this.fields.get(field);\n  }\n\n  problemWithDiscriminator(field: keyof T): string | undefined {\n    const values = this.fields.get(field)!;\n    for (const [value, ctors] of values) {\n      if (ctors.length > 1)\n        return `value '${value}' is repeated in: ${ctors.map((c) => c.name).join(\", \")}`;\n    }\n    if (values.size !== this.constructors.length)\n      return 'field is not present in all classes';\n  }\n\n\n}\n\nclass DiscriminatorReport<T> {\n  public readonly problems = new Map<keyof T, string>();\n  public readonly validFields = new Map<keyof T, Map<PrimitiveValue, Constructor<T>>>();\n\n  reject(k: keyof T, problem: string): this {\n    this.problems.set(k, problem);\n    return this;\n  }\n\n  accept(k: keyof T, mappings: Map<PrimitiveValue, Constructor<T>>): this {\n    this.validFields.set(k, mappings);\n    return this;\n  }\n}\n\nexport function detectDiscriminator<T extends object>(ctors: Constructor<T>[]): keyof T {\n  const report = discriminatorReports(ctors);\n\n  if (report.validFields.size > 1)\n    throw new Error(`Multiple possible discriminator fields: [${Array.from(report.validFields.keys()).join(', ')}]`);\n\n  if (report.validFields.size === 0 && report.problems.size === 0)\n    throw new Error(`No discriminator fields found in: [${ctors.map((c) => c.name).join(', ')}]`);\n\n  const k = first(report.validFields.keys());\n  if (k !== undefined) {\n    return k;\n  }\n\n  const listOfFieldProblems = Array.from(report.problems.entries()).map(([k, problem]) => `${k}: ${problem}`);\n  throw new Error(`No discriminator field found. Considered:\\r\\n${listOfFieldProblems.join('\\r\\n')}`);\n}\n\nexport function discriminatorReports<T extends object>(ctors: Constructor<T>[]): DiscriminatorReport<T> {\n  const candidates = new CandidateDiscriminators<T>(ctors);\n  const report = new DiscriminatorReport<T>();\n  for (const k of candidates.keys()) {\n    const problem = candidates.problemWithDiscriminator(k);\n    if (problem !== undefined)\n      report.reject(k, problem);\n    else\n      report.accept(k, mapKeyValue((k: PrimitiveValue, v: Constructor<T>[]) => [k, v[0]], candidates.get(k)!))\n  }\n  return report;\n}","import {BaseSchema, subSchemaJson} from \"../\";\nimport {DataSchema} from \"../../data\";\nimport {failure, Problems} from \"../../problems\";\nimport {Schema} from \"../../schema\";\nimport {mapValues} from \"../util/maps\";\nimport {Constructor, PrimitiveValue} from \"../util/types\";\nimport {discriminatorReports} from \"./find_discriminators\";\n\nexport class DiscriminatedUnionSchema<T extends object> extends BaseSchema<any, T> {\n  private readonly discriminator: keyof T;\n  private readonly schemasByDiscriminatorValue: Map<PrimitiveValue, Schema<any, T>>;\n\n  constructor(private readonly ctors: Constructor<T>[], discriminator: keyof T) {\n    super();\n\n    this.discriminator = discriminator;\n\n    const report = discriminatorReports(ctors);\n    const schemasByValue = report.validFields.get(this.discriminator);\n    if (schemasByValue === undefined)\n      throw new Error(`Discriminator '${discriminator}' is not valid: ${report.problems.get(discriminator) || 'not found in classes'}.`);\n\n    this.schemasByDiscriminatorValue = mapValues((v) => new DataSchema(v), schemasByValue);\n  }\n\n  conform(value: object): Problems | T {\n    if (typeof value !== 'object')\n      return failure(`expected an object but got ${typeof value}`);\n\n    if (!(this.discriminator in value))\n      return failure(\n        \"no value\",\n        [this.discriminator]);\n\n    const schema = this.schemaFor(value);\n    if (schema === undefined)\n      return failure(\n        `expected one of [${Array.from(this.schemasByDiscriminatorValue.keys()).join(\", \")}]`,\n        [this.discriminator]);\n\n    return schema.conform(value);\n  }\n\n\n  or<NEWIN extends any, NEWOUT>(that: Schema<any, NEWOUT>): Schema<any, T | NEWOUT> {\n    if (that instanceof DiscriminatedUnionSchema\n      && this.discriminator === that.discriminator) {\n      try {\n        // This will give much better error messages, if it's possible\n        // to combine the schemas.\n        return new DiscriminatedUnionSchema(\n          [...this.ctors, ...that.ctors],\n          this.discriminator)\n      } catch (e) {\n        //lean on constructor validation logic\n      }\n    }\n\n    return super.or(that);\n\n  }\n\n  private schemaFor(value: object): Schema<any, T> | undefined {\n    const discriminatorValue = value[this.discriminator as string | symbol];\n    return this.schemasByDiscriminatorValue.get(discriminatorValue);\n  }\n\n  toJSON(toJson?: (s: Schema) => any): any {\n    const allOf: object[] = [];\n    for (const [v, schema] of this.schemasByDiscriminatorValue.entries()) {\n      allOf.push({\n        if: {properties: {[this.discriminator]: {const: v}}},\n        then: subSchemaJson(schema, toJson),\n      })\n    }\n    return {\n      type: \"object\",\n      properties: {\n        [this.discriminator]: true\n      },\n      allOf\n    }\n  }\n}\n\n","import {BaseSchema, failure, Problems, Schema, subSchemaJson, ValidationResult} from \"./\";\nimport {typeDescription} from \"./util/types\";\n\nexport class ArrayOfSchema<T> extends BaseSchema<any[], T[]> {\n  constructor(private readonly itemSchema: Schema<any, T>) {\n    super();\n  }\n\n  conform(value: any): ValidationResult<T[]> {\n    if (!(value instanceof Array))\n      return failure(`${typeDescription(value)} was not an Array`);\n\n    const conformed: T[] = new Array(value.length);\n    let problems = new Problems([]);\n    for (let i = 0; i < value.length; i++) {\n      const conformedItem = this.itemSchema.conform(value[i]);\n      if (conformedItem instanceof Problems)\n        problems = problems.merge(conformedItem.prefixPath([i]));\n      else\n        conformed[i] = conformedItem\n    }\n    if (problems.length > 0)\n      return problems;\n\n    return conformed;\n  }\n\n  toJSON(toJson?: (s: Schema) => any): any {\n    return {\n      type: \"array\",\n      contains: subSchemaJson(\n        this.itemSchema,\n        toJson),\n    }\n  }\n}","import {BaseSchema, failure, ValidationResult} from \"./\";\n\nexport class BooleanSchema extends BaseSchema<any, boolean> {\n  conform(value: any): ValidationResult<boolean> {\n    const t = typeof value;\n    if (value instanceof Boolean || t === \"boolean\")\n      return value;\n\n    if (value instanceof String || t === \"string\") {\n      const s: string = value.toLowerCase();\n      if ([\"true\", \"false\"].indexOf(s) < 0)\n        return failure(`expected a boolean`);\n      return s === 'true';\n    }\n    return failure(`expected a boolean`);\n  }\n\n  toJSON(): any {\n    return {type: \"boolean\"}\n  }\n}","export function toJSON(value: any): any {\n  if (Array.isArray(value))\n    return value.map(v => toJSON(v));\n  if (typeof value === \"object\")\n    return typeof value['toJSON'] === 'function' ? value.toJSON() : value;\n  return value;\n}","import {BaseSchema, optional, Schema, subSchemaJson, ValidationResult} from \"./\";\nimport {toJSON} from \"./util/json\";\n\nexport class DefaultValueSchema<T> extends BaseSchema<any, T> {\n  [optional]: true;\n\n  constructor(private readonly value: () => T,\n              private readonly subschema: Schema<any, T>) {\n    super()\n  }\n\n  conform(value: any): ValidationResult<T> {\n    if (value === undefined)\n      value = this.value();\n\n    return this.subschema.conform(value);\n  }\n\n  toJSON(toJson?: (s: Schema) => any): any {\n    return {\n      ...subSchemaJson(this.subschema, toJson),\n      default: toJSON(this.value()),\n    };\n  }\n}","import {BaseSchema, Schema, subSchemaJson, ValidationResult} from \"./\";\n\nexport class DeferredSchema<IN, OUT> extends BaseSchema<IN, OUT> {\n  private _subschema: Schema<IN, OUT>;\n\n  constructor(private readonly deferred: () => Schema<IN, OUT>) {\n    super();\n  }\n\n  private get subschema(): Schema<IN, OUT> {\n    this._subschema = this.deferred();\n    return this._subschema;\n  }\n\n  conform(value: IN): ValidationResult<OUT> {\n    return this.subschema.conform(value);\n  }\n\n  toJSON(toJson?: (s: Schema) => any): any {\n    return subSchemaJson(this.subschema,toJson);\n  }\n}","import phone from \"phone\";\nimport {BaseSchema, failure, ValidationResult} from \"./\";\nimport {typeDescription} from \"./util/types\";\n\nexport class E164PhoneNumberSchema extends BaseSchema<any, string> {\n  constructor(private readonly defaultCountryIso3166?: string) {\n    super();\n  }\n\n  conform(value: any): ValidationResult<string> {\n\n    if (typeof value !== 'string')\n      return failure(`expected a string but got ${typeDescription(value)}`);\n\n    const result = this.defaultCountryIso3166 ? phone(value, this.defaultCountryIso3166) : phone(value);\n\n    if (result.length === 0) {\n      return failure(`expected a valid E.164 phone number`)\n    } else {\n      return result[0]\n    }\n\n  }\n\n  toJSON(): any {\n    return {\n      type: \"string\",\n      description: \"Phone number\",\n    }\n  }\n}\n","import {typeDescription} from \"./types\";\n\nenum EntryType {\n  StringMember,\n  ReverseMapping,\n  NumericMember,\n  Invalid\n}\n\nexport enum EnumType {\n  InitializedStrings,\n  InitializedIntegers,\n  Mixed\n}\n\nexport function analyseEnum<T>(e: T): { values: Set<any>, type: EnumType } {\n  let allStringMembers = true;\n  let someStringMembers = false;\n  const values = new Set<any>();\n  for (let [k, v] of Object.entries(e) as [string | number, any][]) {\n    if (!isNaN(Number(k)))\n      k = Number(k);\n\n    const valueType: string = typeof v;\n    const keyType: string = typeof k;\n\n    const entryType: EntryType =\n      (keyType === 'string' && valueType === 'string') ? EntryType.StringMember :\n        (keyType === 'string' && valueType === 'number') ? EntryType.NumericMember :\n          (keyType === 'number' && valueType === 'string') ? EntryType.ReverseMapping :\n            EntryType.Invalid;\n\n    if (entryType === EntryType.Invalid)\n      throw new Error(\n        `Entries must be string:number, number:string or string:string. Field '${k}' was ${typeDescription(k)}:${typeDescription(v)}.`);\n\n    if (entryType !== EntryType.StringMember)\n      allStringMembers = false;\n\n    if (entryType !== EntryType.ReverseMapping)\n      values.add(v);\n\n    if (entryType === EntryType.StringMember)\n      someStringMembers = true;\n    else if (e[v.toString()] != k)\n      throw new Error(`Not a proper enum. e[\"${k}\"] = ${JSON.stringify(v)} but e[\"${v}\"] = ${JSON.stringify(e[v])}`);\n  }\n  const type = allStringMembers ? EnumType.InitializedStrings :\n    someStringMembers ? EnumType.Mixed :\n      EnumType.InitializedIntegers;\n\n  return {values, type};\n}","import {BaseSchema, failure, ValidationResult} from \"./\";\nimport {analyseEnum, EnumType} from \"./util/analyseEnum\";\n\n\nexport class EnumValueSchema<T extends object> extends BaseSchema<any, T[keyof T]> {\n  private readonly enumValues: Set<any>;\n  private readonly enumType: EnumType;\n  private failureMessage: string;\n\n  constructor(private readonly e: T) {\n    super();\n    const {values, type} = analyseEnum(this.e);\n\n    this.enumValues = values;\n    this.enumType = type\n\n    this.failureMessage = `expected one of [${Array.from(this.enumValues).map((v) => JSON.stringify(v)).join(', ')}]`;\n  }\n\n  conform(value: any): ValidationResult<T[keyof T]> {\n    if (this.enumValues.has(value))\n      return value;\n\n    return failure(this.failureMessage)\n  }\n\n  toJSON(): any {\n    switch (this.enumType) {\n      case EnumType.InitializedIntegers:\n        return {\n          type: \"number\",\n          enum: [...this.enumValues]\n        };\n      case EnumType.InitializedStrings:\n        return {\n          type: \"string\",\n          enum: [...this.enumValues]\n        };\n      case EnumType.Mixed:\n        return {\n          type: [\"string\", \"number\"],\n          enum: [...this.enumValues]\n        };\n      default:\n        throw new Error(`Enum type ${JSON.stringify(this.enumType)} not supported`);\n    }\n  }\n}","import {BaseSchema, failure, ValidationResult} from \"./\";\nimport {typeDescription} from \"./util/types\";\n\nexport class EqualsSchema<T> extends BaseSchema<any, T> {\n  constructor(public readonly expected: T) {\n    super();\n  }\n\n  conform(value: any): ValidationResult<T> {\n    if (value !== this.expected)\n      return failure(`expected \"${this.expected}\" but got ${typeDescription(value)}: ${JSON.stringify(value)}`);\n    return value;\n  }\n\n  toJSON(): object {\n    return {const: this.expected};\n  }\n\n}","import {BaseSchema, failure, ValidationResult} from \"./\";\nimport {toJSON} from \"./util/json\";\n\nexport class InSchema<T extends number | string | null> extends BaseSchema<any, T> {\n  private readonly values: Set<T>;\n\n  constructor(values: T[]) {\n    super();\n    if(values.length===0)\n      throw new Error('At least one value is required');\n    this.values = new Set(values);\n  }\n\n  conform(value: any): ValidationResult<T> {\n    if (!this.values.has(value))\n      return failure(`expected one of [${Array.from(this.values).join(', ')}]`);\n    return value;\n  }\n\n  toJSON(): any {\n    const values = [...this.values].map(v => toJSON(v));\n    const types = new Set(values.map(v => typeof v));\n\n    return {\n      type: types.size === 1 ? types.values().next().value : [...types],\n      enum: values\n    };\n  }\n}","import {BaseSchema, failure, ValidationResult} from \"./\";\nimport {Constructor, typeDescription} from \"./util/types\";\n\nexport class IsInstanceSchema<T> extends BaseSchema<any, T> {\n  constructor(private readonly c: Constructor<T>) {\n    super();\n  }\n\n  conform(value: any): ValidationResult<T> {\n    return value instanceof this.c ? value : failure(`expected ${this.c.name} but got ${typeDescription(value)}`);\n  }\n\n  /**\n   * This isn't really suitable for json schema,\n   * which doesn't have the concept of a type\n   */\n  toJSON(): any {\n    return {\n      type: \"object\",\n      description: `Instance of ${this.c.name}`,\n      additionalProperties: true,\n    }\n  }\n\n}","export function utcDate(year: number, month: number, date: number, hours?: number, minutes?: number, seconds?: number, ms?: number): Date {\n  const ts = ms ? Date.UTC(year, month, date, hours, minutes, seconds, ms)\n    : seconds ? Date.UTC(year, month, date, hours, minutes, seconds)\n      : minutes ? Date.UTC(year, month, date, hours, minutes)\n        : hours ? Date.UTC(year, month, date, hours)\n          : Date.UTC(year, month, date);\n  return new Date(ts)\n}","import {BaseSchema, failure, ValidationResult} from \"./\";\nimport {utcDate} from \"./util/dates\";\n\nconst regex = /^([1-9][0-9]{3})-([0-1][0-9])-([0-3][0-9])(T([0-2][0-9]):([0-6][0-9])(:([0-6][0-9])(\\.([0-9]{3}))?)?((Z)|(\\+([0-2][0-9]):([0-6][0-9]))))?$/;\n\nexport enum TimeExpectation {\n  NEVER = 'never',\n  ALWAYS = 'always',\n  MAYBE = 'maybe',\n}\n\nexport class IsoUtcDateSchema extends BaseSchema<any, Date> {\n  constructor(private readonly time: TimeExpectation) {\n    super()\n  }\n\n  conform(value: any): ValidationResult<Date> {\n    if (typeof value === 'string') {\n      const match = regex.exec(value);\n      if (!match)\n        return failure(\"expected a valid ISO8601 string\");\n\n      try {\n        const year = Number.parseInt(match[1]);\n        const month = Number.parseInt(match[2]) - 1;\n        const date = Number.parseInt(match[3]);\n\n        if (value.length === 10 && this.time === TimeExpectation.ALWAYS)\n          return failure(\"date should have a time of day component\");\n\n        const hours = match[5] ? Number.parseInt(match[5]) : 0;\n        const minutes = match[6] ? Number.parseInt(match[6]) : 0;\n\n        const seconds = match[8] ? Number.parseInt(match[8]) : 0;\n        const millis = match[10] ? Number.parseInt(match[10]) : 0;\n\n        const offsetHours = match[14] ? Number.parseInt(match[14]) : 0;\n        const offsetMinutes = match[15] ? Number.parseInt(match[15]) : 0;\n\n        if (offsetHours !== 0 || offsetMinutes !== 0)\n          return failure(\"expected a UTC date, with timezone specified as Z or 00:00\");\n\n\n        value = utcDate(\n          year,\n          month,\n          date,\n          hours,\n          minutes,\n          seconds,\n          millis\n        );\n        if (\n          value.getUTCFullYear() !== year ||\n          value.getUTCMonth() !== month ||\n          value.getUTCDate() !== date ||\n          value.getUTCHours() !== hours ||\n          value.getUTCMinutes() !== minutes ||\n          value.getUTCMilliseconds() !== millis\n        ) return failure(\"expected a valid date\");\n      }\n      catch {\n        return failure(\"expected a valid date\")\n      }\n    }\n\n    if (!(value instanceof Date))\n      return failure(\"expected a date or string\");\n\n    if (this.time === TimeExpectation.NEVER && utcDate(value.getUTCFullYear(), value.getUTCMonth(), value.getUTCDate()).getTime() !== value.getTime())\n      return failure(\"date should not have a time of day component\");\n\n    return value;\n  }\n\n  toJSON(): any {\n    return {\n      type: \"string\", format: this.time === TimeExpectation.ALWAYS\n        ? 'date-time'\n        : this.time === TimeExpectation.NEVER\n          ? 'date'\n          : 'date-time'\n    }\n  }\n}","import {BaseSchema, failure, Problems, Schema, SelectSchema, ValidationResult} from \"./\";\n\nexport function setAtPath<T>(obj: T, path: string[], value: any): T {\n  if (path.length === 1) {\n    obj[path[0]] = value;\n    return obj;\n  }\n\n  const key = path[0];\n  setAtPath(obj[key], path.slice(1), value);\n  return obj;\n}\n\nexport class LensSchema<T, U> extends BaseSchema<any, T> {\n  private readonly subschema: Schema<any, U>;\n\n  constructor(private readonly path: string[], subschema: Schema<any, U>) {\n    super();\n    this.subschema = new SelectSchema(path, subschema)\n  }\n\n  conform(value: any): ValidationResult<T> {\n    if (typeof value !== 'object')\n      return failure(\"expected an object\");\n\n    const conformed = this.subschema.conform(value);\n    if (conformed instanceof Problems)\n      return conformed;\n\n    return setAtPath(value, this.path, conformed);\n  }\n\n  toJSON(): any {\n    throw new Error(\"Not implemented\");\n  }\n}\n\nexport enum LensBehaviour {\n  MODIFY_IN_PLACE = 'modify-in-place'\n  // Deep clone is not implemented.\n  // Just a marker enum to flag the behaviour\n}","import {BaseSchema, failure, ValidationResult} from \"./\";\nimport {typeDescription} from \"./util/types\";\n\nexport class LookupSchema<T extends object, V> extends BaseSchema<any, T[keyof T]> {\n  constructor(private readonly lookup: T) {\n    super();\n  }\n\n  conform(value: any): ValidationResult<T[keyof T]> {\n    if (typeof value !== 'string')\n      return failure(`expected a string but got ${typeDescription(value)}`);\n\n    if (value in this.lookup)\n      return this.lookup[value];\n\n    return failure(`expected one of [${Object.keys(this.lookup).map((k) => JSON.stringify(k)).join(', ')}]`)\n  }\n\n  toJSON(): any {\n    return {\n      type: \"string\",\n      enum: Object.keys(this.lookup)\n    }\n  }\n}","import {BaseSchema, failure, problem, Problem, problems, ValidationResult} from \"./\";\n\nexport interface Opts {\n  minimum?: number;\n  exclusiveMinimum?: number;\n  maximum?: number;\n  exclusiveMaximum?: number;\n  multipleOf?: number;\n}\n\nexport class NumberSchema extends BaseSchema<any, number> {\n  constructor(\n    private readonly opts: Opts\n  ) {\n    super();\n  }\n\n  conform(value: any): ValidationResult<number> {\n    if (typeof value !== 'number')\n      return failure('expected a number');\n\n    const {minimum, exclusiveMinimum, maximum, exclusiveMaximum, multipleOf} = this.opts;\n    const p: Problem[] = [];\n\n    if (minimum && !(value >= minimum))\n      p.push(problem(`must be greater than or equal to ${minimum}`));\n\n    if (exclusiveMinimum && !(value > exclusiveMinimum))\n      p.push(problem(`must be greater than ${exclusiveMinimum}`));\n\n    if (maximum && !(value <= maximum))\n      p.push(problem(`must be less than or equal to ${maximum}`));\n\n    if (exclusiveMaximum && !(value < exclusiveMaximum))\n      p.push(problem(`must be less than ${exclusiveMaximum}`));\n\n    if (multipleOf && value % multipleOf !== 0)\n      p.push(problem(`must be multiple of ${multipleOf}`));\n\n    return (p.length > 0)\n      ? problems(...p)\n      : value;\n  }\n\n  toJSON(): any {\n    const {minimum, exclusiveMinimum, maximum, exclusiveMaximum, multipleOf} = this.opts;\n    return {\n      type: \"number\",\n      ...(minimum && {minimum}),\n      ...(exclusiveMinimum && {exclusiveMinimum}),\n      ...(maximum && {maximum}),\n      ...(exclusiveMaximum && {exclusiveMaximum}),\n      ...(multipleOf && {multiple: multipleOf}),\n    }\n  }\n\n}","import {BaseSchema, failure, Problems, Schema, subSchemaJson, ValidationResult} from \"./\";\nimport {typeDescription} from \"./util/types\";\n\nexport interface SchemaOverrides<IN, OUT> {\n  failure?: string | ((value: IN) => Problems);\n}\n\nexport class OverrideSchema<IN, OUT> extends BaseSchema<IN, OUT> {\n  constructor(private readonly subschema: Schema<IN, OUT>,\n              private readonly overrides: SchemaOverrides<IN, OUT>) {\n    super();\n  }\n\n  conform(value: IN): ValidationResult<OUT> {\n    const result = this.subschema.conform(value);\n    return result instanceof Problems\n      ? this.failure(value, result)\n      : result;\n  }\n\n  private failure(value: IN, original: Problems): Problems {\n    const f = this.overrides.failure;\n\n    if (!f) {\n      return original;\n    }\n    else if (typeof f === 'string') {\n      return failure(f)\n    }\n    else if (f instanceof Function) {\n      return f(value);\n    }\n    else {\n      throw new Error(`Not implemented for ${typeDescription(f)}`);\n    }\n  }\n\n  toJSON(toJson?: (s: Schema) => any): any {\n    return subSchemaJson(this.subschema, toJson);\n  }\n}","import {BaseStringSchema, failure, ValidationResult} from \"./\";\n\nexport class RegExpSchema extends BaseStringSchema {\n  constructor(private readonly r: RegExp) {\n    super();\n  }\n\n  conformString(value: string): ValidationResult<string> {\n    return this.r.test(value) ? value : failure(`did not match ${this.r}`);\n  }\n\n  toJSON(): any {\n    return {\n      ...super.toJSON(),\n      pattern: this.r.toString().replace(/^\\//, '').replace(/\\/$/, '')\n    }\n  }\n}","import {BaseSchema, failure, Problems, Schema, ValidationResult} from \"./\";\n\nexport class SelectSchema<T> extends BaseSchema<any, T> {\n  constructor(private readonly path: string[],\n              private readonly subschema: Schema<any, T>) {\n    super()\n  };\n\n  conform(value: any): ValidationResult<T> {\n    if (typeof value !== 'object')\n      return failure(\"expected an object\");\n\n    let target: any = value;\n    let atPath: string[] = [];\n    for (const key of this.path) {\n      atPath.push(key);\n      if (!(key in target))\n        return failure(\"no value\", atPath);\n      target = target[key];\n    }\n    const result = this.subschema.conform(target);\n    return result instanceof Problems\n      ? result.prefixPath(this.path)\n      : result;\n  }\n\n  toJSON(): any {\n    throw new Error(\"Not implemented\");\n  }\n}","import {BaseSchema, failure, Problems, Schema, subSchemaJson, ValidationResult} from \"./\";\nimport {typeDescription} from \"./util/types\";\n\nexport class SetOfSchema<T> extends BaseSchema<any, Set<T>> {\n  constructor(private readonly itemSchema: Schema<any, T>) {\n    super();\n  }\n\n  conform(value: any): ValidationResult<Set<T>> {\n    if (!(value instanceof Set || value instanceof Array))\n      return failure(`${typeDescription(value)} was not an Array or a Set`);\n\n    const entries: Iterable<[any, any]> = value instanceof Set ? value.entries() : value.map((v, i) => [i, v] as [any, any]);\n\n    const conformed = new Set<T>();\n    let problems = new Problems([]);\n    for (const [k, v] of entries) {\n      const c = this.itemSchema.conform(v);\n      if (c instanceof Problems)\n        problems = problems.merge(c.prefixPath([k]));\n      else\n        conformed.add(c);\n    }\n    if (problems.length > 0)\n      return problems;\n\n    return conformed;\n  }\n\n  toJSON(toJson?: (s: Schema) => any): any {\n    return {\n      type: \"array\",\n      items: subSchemaJson(this.itemSchema, toJson)\n    }\n  }\n\n}","import {BaseSchema, failure, problem, Problem, problems, ValidationResult} from \"./\";\nimport {typeDescription} from \"./util/types\";\n\nexport class UniqueSchema<T, V> extends BaseSchema<T[], T[]> {\n  constructor(private readonly keyfn: (t: T) => V) {\n    super()\n  };\n\n  conform(value: any): ValidationResult<T[]> {\n    if (!(value instanceof Array))\n      return failure(`${typeDescription(value)} was not an Array`);\n\n    const countKeys = (m, t, i) => {\n      const k: V = this.keyfn(t);\n      if (!m.has(k))\n        m.set(k, []);\n      // @ts-ignore\n      m.get(k).push(i);\n      return m;\n    };\n\n    const keyCounts: Map<V, number[]> = value.reduce(countKeys, new Map<V, number[]>());\n    const p: Problem[] = [];\n    for (const [k, indexes] of keyCounts.entries()) {\n      if (indexes.length === 1) continue;\n      const message = `duplicate at indexes: [${indexes}]`;\n      const map = indexes.map((i) => problem(message, [i]));\n      p.push(...map)\n    }\n    return p.length > 0 ? problems(...p) : value;\n  }\n\n  toJSON(): any {\n    return {\n      type: \"array\",\n      description: \"unique values\"\n    }\n  }\n}","import validator from \"validator\";\nimport {failure, BaseStringSchema, ValidationResult} from \"./\";\n\nexport interface IsURLOptions {\n  protocols?: string[];\n  require_tld?: boolean;\n  require_protocol?: boolean;\n  require_valid_protocol?: boolean;\n  allow_underscores?: boolean;\n  host_whitelist?: false | (string | RegExp)[];\n  host_blacklist?: false | (string | RegExp)[];\n  allow_trailing_dot?: boolean;\n  allow_protocol_relative_urls?: boolean;\n}\n\nexport class UrlSchema extends BaseStringSchema {\n  constructor(private readonly opts: IsURLOptions) {\n    super();\n  }\n\n  conformString(value: string): ValidationResult<string> {\n    if (validator.isURL(value, this.opts)) return value;\n    return failure(`not a valid url: ${value}`)\n  }\n\n  toJSON(): any {\n    return {...super.toJSON(), format: \"url\"}\n  }\n}","import {failure, RegExpSchema, ValidationResult} from \"./\";\n\nconst REGEX = /^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89ab][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$/;\n\nexport class UuidSchema extends RegExpSchema {\n  constructor() {\n    super(REGEX);\n  }\n\n  conformString(value: string): ValidationResult<string> {\n    const conformed = value.toLowerCase();\n    return REGEX.test(conformed) ? conformed : failure(`not a valid uuid: ${value}`);\n  }\n  toJSON(): any {\n    return {...super.toJSON(), format: \"uuid\"}\n  }\n}","import {isSchema, ObjectSchema, Problems, ValidationError} from \"./impl\";\nimport {Constructor} from \"./impl/util/types\";\n\nconst SCHEMA_SYMBOL = Symbol('schema');\n\nexport function schemaOf<T extends object>(ctor: Constructor<T>): ObjectSchema<T> {\n  for (let search: Function = ctor; search; search = Object.getPrototypeOf(search)) {\n    const pd = Object.getOwnPropertyDescriptor(search, SCHEMA_SYMBOL);\n    if (pd !== undefined)\n      return pd.value;\n  }\n  throw new Error(`No schema on ${ctor.name}- not annotated with @data?`);\n}\n\nlet SUSPEND_VALIDATION = false;\n\nexport function suspendValidation<T>(f: () => T): T {\n  try {\n    SUSPEND_VALIDATION = true;\n    return f();\n  } finally {\n    SUSPEND_VALIDATION = false;\n  }\n}\n\n\n// TODO: add generic constraints to IN/OUT on Schema?\nexport function hasSchema<C extends { new(...args: any[]): object }>(schema: ObjectSchema<C>): (c: C) => C {\n  return function <C extends { new(...args: any[]): object }>(c: C): C {\n    const hackClassName = {};\n    hackClassName[c.name] = class extends c {\n      constructor(...args: any[]) {\n        super(...args);\n        if (SUSPEND_VALIDATION)\n          return;\n\n        for (const [k, v] of Object.entries(this)) {\n          if (isSchema(v))\n            this[k] = undefined;\n        }\n        const conformed = schema.conformInPlace(this);\n        if (conformed instanceof Problems) {\n          throw new ValidationError(this, conformed);\n        }\n      };\n    };\n\n    const decorated = hackClassName[c.name];\n    Object.defineProperty(decorated, SCHEMA_SYMBOL, {value: schema, writable: false});\n    return decorated;\n  }\n}\n\n","import {EqualsSchema, ObjectSchema, StrictPattern} from \"./impl\";\nimport {Schema} from \"./schema\";\n\nexport type Schemaish = Schema<any, any> | Function | number | string | boolean | object;\n\nexport function schematizeEntries<T extends object>(object: Object): StrictPattern<T> {\n  const fixed = <StrictPattern<T>>{};\n  for (const [k, v] of Object.entries(object)) {\n    fixed[k] = schematize(v);\n  }\n  return fixed;\n}\n\ntype LiftObject<T> = T extends object ? T : never;\n\nexport function schematize<IN, OUT>(x: Schemaish): Schema<IN, OUT> {\n  switch (typeof x) {\n    case \"string\":\n    case \"number\":\n    case \"boolean\":\n      return new EqualsSchema(x)  as any as Schema<IN, OUT>;\n\n    case \"object\":\n      const obj = (x as object);\n\n      if ('conform' in obj && typeof x['conform'] === \"function\")\n        return x as Schema<IN, OUT>;\n\n      else if (Object.getPrototypeOf(x) === Object.prototype)\n        return new ObjectSchema<LiftObject<OUT>>(\n          schematizeEntries(obj)) as any as Schema<IN, OUT>;\n      else\n        throw Error(`Cannot build schema from non-plain object ${Object.getPrototypeOf(x).name}`);\n\n    default:\n      throw Error(`Cannot build schema from ${typeof x}: ${x}`);\n  }\n}","import {empty, Path, Problems, ValidationErrorOpts, wrapAssociative} from \"./impl\";\nimport {isPrimitive} from \"./impl/util/types\";\n\nexport function pathsEq(a: Path, b: Path) {\n  return a.length === b.length\n    && a.every((v, i) => v === b[i]);\n}\n\nexport function pathStartsWith(path: Path, startsWith: Path) {\n  return path.length >= startsWith.length\n    && startsWith.every((v, i) => v === path[i]);\n}\n\nfunction intertwingledValue<T>(actual: any, problems: Problems, path: Path): any {\n  if (isPrimitive(actual))\n    return actual;\n\n  // Arrays or objects\n  const associative = wrapAssociative(actual);\n\n  const keys = new Set(associative.keys());\n\n  const missingKeys = problems.problems\n    .filter(p =>\n      // problems for direct children of path (but not ancestors)\n      p.path.length === path.length + 1\n      && pathStartsWith(p.path, path)\n\n      // ...that are not in actual\n      && !keys.has(p.path[-1]))\n    .map(p => p.path[p.path.length - 1]);\n\n  return [...keys, ...missingKeys]\n    .reduce((result, k) => {\n      result[k] = intertwingle(actual[k], problems, [...path, k]);\n      return result;\n    }, empty(actual));\n}\n\n/**\n * Returns an object in the same shape as actual, but with invalid values replaced with an error report.\n *\n * e.g.\n *\n * const actual = {right: 'right', wrong:'wrong'};\n * const problems = [{path: ['wrong'], message: 'error message'};\n * intertwingle(actual, problems);\n *\n * will return\n *\n * {right: 'right', wrong: {value: 'wrong', errors: ['error message']}}\n *\n * This is suitable for a structural diff with the actual value, where only\n * problem fields will be mismatches\n */\nexport function intertwingle(actual: any, problems: Problems, path: Path = []): any {\n  const myProblems = problems.problems\n    .filter(p => pathsEq(path, p.path))\n    .map(p => p.message);\n\n  const intertwingled = intertwingledValue(actual, problems, path);\n\n  return myProblems.length === 0\n    ? intertwingled\n    : myProblems.length === 1\n      ? myProblems[0]\n      : myProblems;\n}\n\nexport class ValidationError extends Error {\n  public readonly actual?: any;\n  public readonly expected?: any;\n\n  constructor(actual: any,\n              public readonly problems: Problems,\n              {\n                message = 'Validation failed',\n                leakActualValuesInError = false,\n              }: Partial<ValidationErrorOpts> = {}\n  ) {\n    super(`${message}:\\n${problems}${leakActualValuesInError ? `\\nactual:${JSON.stringify(actual, null, 2)}\\n` : ''}`);\n    if (leakActualValuesInError) {\n      this.actual = actual;\n      this.expected = intertwingle(actual, problems, []);\n      showDiff: true\n    }\n  }\n\n\n}","import {\n  Behaviour,\n  conform,\n  isError,\n  MissingItemBehaviour,\n  Pattern,\n  patternItemToSchema,\n  Schema,\n  UnexpectedItemBehaviour,\n  usingBehaviour,\n  ValidationError, ValidationOpts\n} from \"./impl\";\n\nexport type Likeable = Array<any> | object;\nconst DEFAULT_BEHAVIOUR: Behaviour = {\n  missing: MissingItemBehaviour.PROBLEM,\n  unexpected: UnexpectedItemBehaviour.IGNORE,\n  leakActualValuesInError: true,\n};\n\n/**\n * Conforms actual to the schema, or to the expected pattern using object();\n *\n * Returns the conformed value if successful.\n *\n * Otherwise throws an assertion Error, with actual, expected and showDiff, compatible with AssertionError, as used by\n * mocha, WebStorm, etc.\n *\n * The 'expected' field on the error will produce a usable diff with the actual value. See documentation on\n * intertwingle() for the shape of 'expected' on the error.\n */\nexport function like<T extends Likeable>(\n  actual: any,\n  expected: Pattern<T> | Schema<any, T>,\n  opts: Partial<ValidationOpts> = {}\n): T {\n  const behaviour = Object.assign({}, DEFAULT_BEHAVIOUR, opts);\n  const schema: Schema = patternItemToSchema(expected as any);\n\n  const result = usingBehaviour(\n    behaviour,\n    () => conform(schema, actual));\n\n  if (isError(result)) {\n    throw new ValidationError(\n      actual,\n      result,\n      {\n        leakActualValuesInError: behaviour.leakActualValuesInError,\n        message: opts.message\n      });\n  }\n\n  return result as T;\n}","import {conform} from \"../helpers\"\nimport {\n  BaseSchema,\n  BehaviourSchema,\n  failure,\n  isSchema,\n  isSuccess,\n  ObjectSchema,\n  Pattern,\n  Problems,\n  Schema,\n  UnexpectedItemBehaviour,\n  ValidationResult\n} from \"../impl\";\nimport {subSchemaJson} from \"../jsonSchema\";\n\nexport class ConditionalSchema<IN extends object, OUT, MATCH = any> extends BaseSchema<IN, OUT> {\n  constructor(\n    private readonly matches: [Schema<IN>, Schema<IN, OUT>][]) {\n    super();\n  }\n\n  conform(value: IN): ValidationResult<OUT> {\n    let problems = failure('could not match any case');\n    for (const [case_, schema] of this.matches) {\n      const matchResult = conform(case_, value);\n      if (isSuccess(matchResult))\n        return conform(schema, value);\n      else\n        problems = problems.merge(matchResult);\n    }\n    return problems as Problems;\n  }\n\n  case<OTHER extends object>(case_: Pattern<OTHER> | Schema<IN, any>, schema: Schema<IN, OTHER>): ConditionalSchema<IN, OUT | OTHER> {\n    const caseSchema = isSchema(case_)\n      ? case_\n      : new BehaviourSchema({unexpected: UnexpectedItemBehaviour.IGNORE}, new ObjectSchema(case_));\n\n    return new ConditionalSchema<IN, OUT | OTHER>(\n      [...this.matches, [caseSchema, schema]]);\n  }\n\n  toJSON(toJson?: (s: Schema) => any): any {\n    if (this.matches.length === 0)\n      return false;\n\n    function subs(schema:Schema):any{\n      const result = subSchemaJson(schema, toJson);\n      delete result['additionalProperties'];\n      delete result['required'];\n      delete result['type'];\n      return result;\n    }\n    return this.matches\n      .reverse()\n      .reduce((result, [condition, schema]) => {\n        return {\n          if: subs(condition),\n          then: subSchemaJson(schema, toJson),\n          ...(result ? {else: result} : {})\n        };\n      }, undefined);\n  }\n}\n\n","import {\n  conform,\n  failure,\n  hasSchema,\n  isSchema,\n  ObjectSchema,\n  Problems,\n  Schema,\n  schemaOf,\n  schematizeEntries,\n  StrictPattern,\n  suspendValidation,\n  usingBehaviour,\n  ValidationError,\n  ValidationOpts,\n  ValidationResult\n} from \"./impl\";\nimport {BaseSchema} from \"./impl/core\";\nimport {Constructor, isPrimitive} from \"./impl/util/types\";\n\nexport function data<C extends Constructor>(c: C): C {\n  // suspendValidation is required to allow calling parent constructor\n  const objectWithDefaults = suspendValidation(() => new c() as StrictPattern<C>);\n\n  for (const [k, v] of Object.entries(objectWithDefaults)) {\n    if (!(isSchema(v) || isPrimitive(v)))\n      throw new Error(`Field '${k}' on ${c.name} is neither a schema nor a primitive value`);\n  }\n\n  const schema = new ObjectSchema<C>(schematizeEntries(objectWithDefaults));\n  return hasSchema(schema)(c);\n}\n\nexport function intersect<A extends object, B extends object>\n(a: Constructor<A>, b: Constructor<B>): Constructor<A & B> {\n\n  const schema: ObjectSchema<A & B> = schemaOf(a).intersect(schemaOf(b));\n\n  @hasSchema(schema as any)\n  class Intersection {\n  }\n\n  for (let id in a.prototype) {\n    (<any>Intersection.prototype)[id] = (<any>a.prototype)[id];\n  }\n  for (let id in b.prototype) {\n    if (!Intersection.prototype.hasOwnProperty(id)) {\n      (<any>Intersection.prototype)[id] = (<any>b.prototype)[id];\n    }\n  }\n  return Intersection as any as Constructor<A & B>;\n}\n\nexport function makeInstance<T>(c: Constructor<T>, obj: object): T {\n  return Object.assign(Object.create(c.prototype), obj);\n}\n\nexport function conformAs<T extends object>(c: Constructor<T>, obj: object): ValidationResult<T> {\n  const result = conform(schemaOf(c), obj);\n  if (result instanceof Problems)\n    return result;\n  return makeInstance(c, result);\n}\n\n\nexport function build<T extends object>(\n  c: Constructor<T>,\n  values: any,\n  opts: Partial<ValidationOpts> = {}): T {\n  const conformed = usingBehaviour(opts, () => conformAs(c, values));\n  if (conformed instanceof Problems) {\n    throw new ValidationError(values, conformed, opts);\n  }\n  return conformed;\n}\n\n/**\n * Call this instead of build() when constructing data instances\n * by specifying fields in code. The compiler will complain if\n * fields are missing.\n *\n * `build(A, {})` will NOT cause the compiler to complain,\n * even if `{}` is missing fields `A` requires.\n *\n * `construct(A, {})` WILL cause the compiler to complain if\n * `{}` is missing fields `A` requires.\n */\nexport function construct<T extends object>(\n  c: Constructor<T>,\n  value: T,\n  opts: Partial<ValidationOpts> = {}): T {\n  return build(c, value, opts);\n}\n\nexport class DataSchema<T extends object> extends BaseSchema<any, T> {\n  public readonly subSchema: Readonly<ObjectSchema<T>>;\n\n  constructor(private readonly c: Constructor<T>) {\n    super();\n    this.subSchema = schemaOf(c);\n  }\n\n  conform(value: any): Problems | T {\n    if (value instanceof this.c) return value;\n    if (typeof value !== 'object') return failure(`Expected an object but got a ${typeof value}`);\n\n    try {\n      return build(this.c, value)\n        ;\n    } catch (e) {\n      if (e instanceof ValidationError) {\n        return e.problems;\n      }\n      throw e;\n    }\n  }\n\n  toJSON(toJson?: (s: Schema) => any): any {\n    return this.subSchema.toJSON(toJson);\n  }\n}\n","export function identity<T>(t: T): T {\n  return t;\n}","import {DataSchema} from \"./data\";\nimport {\n  ArrayOfSchema,\n  Behaviour,\n  BehaviourSchema,\n  BooleanSchema,\n  ConditionalSchema,\n  DefaultValueSchema,\n  DeferredSchema,\n  DelegatingSchema,\n  detectDiscriminator,\n  DiscriminatedUnionSchema,\n  E164PhoneNumberSchema,\n  EnumValueSchema,\n  EqualsSchema,\n  failure,\n  InSchema,\n  IsInstanceSchema,\n  IsoUtcDateSchema,\n  isSchema,\n  IsURLOptions,\n  LensBehaviour,\n  LensSchema,\n  LookupSchema,\n  MapSchema,\n  MissingItemBehaviour,\n  NumberSchema,\n  ObjectSchema,\n  ObjOfSchema,\n  Opts,\n  OrSchema,\n  OverrideSchema,\n  Pattern,\n  Problems,\n  RegExpSchema,\n  Schema,\n  schemaOf,\n  SchemaOverrides,\n  schematizeEntries,\n  SelectSchema,\n  SetOfSchema,\n  StrictPattern,\n  StringSchema,\n  TagSchemaAsOptional,\n  TimeExpectation,\n  TupleSchema,\n  UnexpectedItemBehaviour,\n  UniqueSchema,\n  UrlSchema,\n  UuidSchema,\n} from \"./impl\";\nimport {identity} from \"./impl/util/functions\";\nimport {Constructor} from \"./impl/util/types\";\n\nexport function __<IN, OUT>(s: Schema<IN, OUT>): OUT {\n  return s.__();\n}\n\n/**\n * Marks a field as optional. MUST be used as the outer schema:\n *\n * Ok:\n *\n * @data\n * class Cat {\n *   name?:string =__(opt(isstring().or(isnumber())))\n * }\n *\n * Not ok:\n *\n * @data\n * class Cat {\n *   name?:string =__(opt(isstring()).or(isnumber())\n * }\n */\nexport function opt<IN, OUT>(s: Schema<any, OUT>): Schema<any, OUT | undefined> {\n  return new TagSchemaAsOptional(s);\n}\n\nexport function isdata<T extends object>(constructor: Constructor<T>): Schema<any, T> {\n  return new DataSchema(constructor);\n}\n\nexport function partial<T extends object>(type: Constructor<T>): Schema<any, Partial<T>> {\n  return onMissing(schemaOf(type), MissingItemBehaviour.IGNORE);\n}\n\nexport function onMissing<IN, OUT>(schema: Schema<IN, OUT>, behaviour: MissingItemBehaviour): Schema<IN, OUT> {\n  return withBehaviour(schema, {missing: behaviour});\n}\n\nexport function onUnexpected<IN, OUT>(schema: Schema<IN, OUT>, behaviour: UnexpectedItemBehaviour): Schema<IN, OUT> {\n  return withBehaviour(schema, {unexpected: behaviour});\n}\n\nexport function withBehaviour<IN, OUT>(schema: Schema<IN, OUT>, behaviour: Partial<Behaviour>): Schema<IN, OUT> {\n  return new BehaviourSchema(behaviour, schema);\n}\n\nfunction deepNullablePattern(fieldSchemaArray: [string, Schema][]): Pattern<any> {\n  const nullableFieldsObjectPattern = {};\n  for (const [k, s] of fieldSchemaArray) {\n    if (\"fieldSchemaArray\" in s) { // TODO testing if schema represents an object should be different\n      const nullableFieldsObjectSchema = new ObjectSchema(deepNullablePattern((s as ObjectSchema<any>).fieldSchemaArray));\n      nullableFieldsObjectPattern[k] = new OrSchema([nullableFieldsObjectSchema, isnull()]);\n    } else {\n      nullableFieldsObjectPattern[k] = new OrSchema([s, isnull()]);\n    }\n  }\n  return nullableFieldsObjectPattern\n}\n\nexport function deepNullable<T extends object>(type: Constructor<T>): Schema<any, DeepNullable<T>> {\n  const objectSchema: ObjectSchema<T> = schemaOf(type);\n\n  return new ObjectSchema(deepNullablePattern(objectSchema.fieldSchemaArray));\n}\n\nexport type Nullable<T> = T | null\n\nexport type DeepNullable<T extends object> = {\n  [P in keyof T]: T[P] extends object ? DeepNullable<T[P]> : Nullable<T[P]>;\n}\n\nexport function eq<T>(value: T): Schema<any, T> {\n  return new EqualsSchema(value);\n}\n\nexport function gt(value: number): Schema<any, number> {\n  return new NumberSchema({exclusiveMinimum: value});\n}\n\nexport function lt(value: number): Schema<any, number> {\n  return new NumberSchema({exclusiveMaximum: value});\n}\n\nexport function gte(value: number): Schema<any, number> {\n  return new NumberSchema({minimum: value});\n}\n\nexport function lte(value: number): Schema<any, number> {\n  return new NumberSchema({maximum: value});\n}\n\nexport interface RangeOpts {\n  lowerInclusive: boolean;\n  upperInclusive: boolean;\n}\n\nexport function range(\n  from: number,\n  to: number,\n  {lowerInclusive = true, upperInclusive = false}: Partial<RangeOpts> = {})\n  : Schema<any, number> {\n\n  const min: Opts = lowerInclusive\n    ? {minimum: from}\n    : {exclusiveMinimum: from};\n\n  const max: Opts = upperInclusive\n    ? {maximum: to}\n    : {exclusiveMaximum: to};\n\n  return isnumber({...min, ...max});\n}\n\nexport function isnull(): Schema<any, null> {\n  return eq(null);\n}\n\nexport function isobject(): Schema<any, object> {\n  return withBehaviour(new ObjectSchema({}), {unexpected: UnexpectedItemBehaviour.IGNORE});\n}\n\nexport function isundefined(): Schema<any, undefined> {\n  return eq(undefined);\n}\n\nexport function isany(): Schema<any, any> {\n  return schema((x) => x, () => true);\n}\n\nexport function fail(problems: Problems = failure('always fails')): Schema<any, any> {\n  return schema(() => problems, () => false);\n}\n\nexport function arrayof<T>(schema: Schema<any, T>): Schema<any, T[]> {\n  return new ArrayOfSchema(schema);\n}\n\nexport function setof<T>(schema: Schema<any, T>): Schema<any, Set<T>> {\n  return new SetOfSchema(schema);\n}\n\nexport function enumvalue<T extends object>(e: T): Schema<any, T[keyof T]> {\n  return new EnumValueSchema(e);\n}\n\nexport function enumkey<T extends object>(e: T): Schema<any, T[keyof T]> {\n  const stringKeysOnly = {};\n  for (let [k, v] of Object.entries(e)) {\n    if (isNaN(Number(k)))\n      stringKeysOnly[k] = v;\n  }\n\n  return lookup(stringKeysOnly);\n}\n\nexport function lookup<T extends object>(e: T): Schema<any, T[keyof T]> {\n  return new LookupSchema(e);\n}\n\nexport function discriminated<T extends object>(...ctors: Constructor<T>[]): Schema<any, T> {\n  return discriminatedBy(detectDiscriminator(ctors), ...ctors);\n}\n\nexport function discriminatedBy<T extends object>(discriminator: keyof T,\n                                                  ...ctors: Constructor<T>[]): Schema<any, T> {\n  return new DiscriminatedUnionSchema<T>(ctors, discriminator);\n}\n\nexport function isstring(): Schema<any, string> {\n  return new StringSchema();\n}\n\nexport function isinstance<T>(c: Constructor<T>): Schema<any, T> {\n  return new IsInstanceSchema(c);\n}\n\nexport function matches(r: RegExp): Schema<any, string> {\n  return new RegExpSchema(r);\n}\n\nexport function conditional(): ConditionalSchema<any, any> {\n  return new ConditionalSchema([]);\n}\n\nexport function isboolean(): Schema<any, boolean> {\n  return new BooleanSchema();\n}\n\nexport function isIn<T extends number | string | null>(...values: T[]): Schema<any, T> {\n  return new InSchema<T>(values);\n}\n\nexport function isurl(opts?: IsURLOptions): Schema<any, string> {\n  return new UrlSchema(opts || {});\n}\n\nexport function isuuid(): Schema<any, string> {\n  return new UuidSchema();\n}\n\nexport function isnumber(opts: Opts = {}): Schema<any, number> {\n  return new NumberSchema(opts);\n}\n\nconst DATE_TIME = new IsoUtcDateSchema(TimeExpectation.ALWAYS);\n\nexport function isoUtcDateTime(): Schema<any, Date> {\n  return DATE_TIME;\n}\n\nconst DATE = new IsoUtcDateSchema(TimeExpectation.NEVER);\n\nexport function isoDateOnly(): Schema<any, Date> {\n  return DATE;\n}\n\n/**\n * E.164 phone number normaliser\n * if no default country is passed, it validates number depending on coutry calling code (has to begin with '+')\n */\nexport function e164PhoneNumber(defaultCountryIso3166?: string): Schema<any, string> {\n  return new E164PhoneNumberSchema(defaultCountryIso3166);\n}\n\nexport function object<T extends object>(\n  pattern: StrictPattern<T>\n): Schema<any, T> {\n  return new ObjectSchema<T>(pattern);\n}\n\nexport function deepPartial<T extends object>(\n  pattern: Pattern<T>): Schema<any, T> {\n  return onUnexpected<any, T>(new ObjectSchema<T>(pattern), UnexpectedItemBehaviour.IGNORE);\n}\n\n/**\n * An object where all values conform to schema\n */\nexport function objof<T>(schema: Schema<any, T>): Schema<any, { [k: string]: T }> {\n  return new ObjOfSchema(schema);\n}\n\nexport function map<K, V>(entryPattern: Pattern<{}> | Map<K, Schema<any, V>>): Schema<any, Map<K, V>> {\n  const subSchema = new ObjectSchema<any>(entryPattern instanceof Map\n    ? schematizeEntries(entryPattern)\n    : entryPattern);\n  return new MapSchema<K, V>(subSchema);\n}\n\nexport function tuple<A>(a: Schema<any, A>): Schema<any, [A]>;\n\nexport function tuple<A, B>(a: Schema<any, A>, b: Schema<any, B>): Schema<any, [A, B]>;\n\nexport function tuple<A, B, C>(a: Schema<any, A>, b: Schema<any, B>, c: Schema<any, C>): Schema<any, [A, B, C]>;\n\nexport function tuple<A, B, C, D>(a: Schema<any, A>, b: Schema<any, B>, c: Schema<any, C>, d: Schema<any, D>): Schema<any, [A, B, C, D]> ;\n\nexport function tuple<A, B, C, D, E>(a: Schema<any, A>, b: Schema<any, B>, c: Schema<any, C>, d: Schema<any, D>, e: Schema<any, E>): Schema<any, [A, B, C, D, E]>;\n\nexport function tuple<T extends any[]>(...s: Schema[]): Schema<any, T> ;\n\nexport function tuple<T extends any[]>(...s: Schema[]): Schema<any, T> {\n\n  return new TupleSchema(s);\n}\n\nexport function schema<IN, OUT>(\n  conform: (value: IN) => Problems | OUT,\n  toJSON?: () => any): Schema<IN, OUT> {\n  return new DelegatingSchema<IN, OUT>(conform, toJSON);\n}\n\n\nexport function predicate<T>(predicate: (value: T) => boolean,\n                             failureMessage?: ((value: any) => string) | string): Schema<T, T> {\n\n  function buildPredicateMessageFunction(message: ((value: any) => string) | string | undefined, predicate: (x: any) => boolean): (value: any) => string {\n    switch (typeof message) {\n      case 'string':\n        return () => message as string;\n      case 'function':\n        return message as () => string;\n      case 'undefined':\n        return () => predicate.toString();\n      default:\n        throw new Error(`Not a valid message ${message}`);\n    }\n  }\n\n  const messageFn = buildPredicateMessageFunction(failureMessage, predicate);\n  return schema(\n    (x) => predicate(x) === true ? x : failure(messageFn(x)))\n}\n\n/**\n * Note that when using `defer()` to recursively nest schemas, by default `toJSON()` will\n * stack overflow.\n *\n * You need to make sure that all schemas used in recursion are in the definitions\n * when calling jsonSchema(), so that they get replaced by $refs.\n *\n * ```\n * const node = object({children: arrayof(defer(() =>node))});\n *\n * // this will overflow:\n * node.toJSON();\n *\n * // this will not:\n * jsonSchema({definitions:{node: node}};\n * ```\n */\nexport function defer<IN, OUT>(factory: () => Schema<IN, OUT>): Schema<IN, OUT> {\n  return new DeferredSchema(factory);\n}\n\nexport {SchemaOverrides} from \"./impl/override\";\n\nexport function override<IN, OUT>(s: Schema<IN, OUT>, o: SchemaOverrides<IN, OUT>) {\n  return new OverrideSchema(s, o);\n}\n\nexport function unique<T>(): Schema<any, T[]> {\n  return uniqueBy(identity);\n}\n\nexport function uniqueBy<T, V = any>(fn: (t: T) => V): Schema<T[], T[]> {\n  return new UniqueSchema<T, V>(fn);\n}\n\nexport function select<T>(path: string[], s: Schema<any, T>): Schema<any, T> {\n  return new SelectSchema(path, s);\n}\n\nexport function anyOf<T>(...items: (T | Schema<any, T>)[]): Schema<any, T> {\n  const result: Schema<any, T> | undefined = items.reduce(\n    (result: Schema<any, T> | undefined, item: Schema<any, T> | T): Schema<any, T> => {\n      const schema = isSchema(item) ? item : eq(item);\n      return result ? result.or(schema) : schema;\n    }, undefined);\n  return result || fail(failure('oneOf() with no values provided'));\n}\n\n\nexport {LensBehaviour} from './impl/lens'\n\n/**\n * Expects an object. Conforms value at path using schema, and returns the outer object.\n *\n * lens([\"a\", \"b\"], eq(\"valid\")).conform({a:{b:\"valid\"}}) returns {a:{b:\"valid\"}}\n */\nexport function lens<T, U>(path: string[], s: Schema<any, U>): Schema<any, T> {\n  return new LensSchema(path, s);\n}\n\nexport function defaultValue<T>(value: () => T, schema: Schema<any, T>): Schema<any, T> {\n  return new DefaultValueSchema(value, schema)\n}"],"names":["merge"],"mappings":"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"}