{"version":3,"file":"vice.umd.js","sources":["../src/problems.ts","../src/helpers.ts","../src/impl/util/types.ts","../src/impl/core.ts","../src/impl/util/maps.ts","../src/jsonSchema.ts","../src/impl/associative/behaviour.ts","../src/impl/associative/associative.ts","../src/impl/associative/map.ts","../src/impl/util/magic.ts","../src/impl/associative/obj.ts","../src/impl/associative/objof.ts","../src/impl/associative/tuple.ts","../src/impl/associative/wrap.ts","../src/impl/util/iterables.ts","../src/impl/discriminated_union/find_discriminators.ts","../src/impl/discriminated_union/index.ts","../src/impl/arrayof.ts","../src/impl/bool.ts","../src/impl/util/json.ts","../src/impl/defaultValue.ts","../src/impl/deferred.ts","../src/impl/e164PhoneNumber.ts","../src/impl/util/analyseEnum.ts","../src/impl/enumvalue.ts","../src/impl/eq.ts","../src/impl/isin.ts","../src/impl/isinstance.ts","../src/impl/util/dates.ts","../src/impl/isoUtcDateTime.ts","../src/impl/lens.ts","../src/impl/lookup.ts","../src/impl/number.ts","../src/impl/override.ts","../src/impl/regexp.ts","../src/impl/select.ts","../src/impl/setof.ts","../src/impl/unique.ts","../src/impl/url.ts","../src/impl/uuid.ts","../src/hasschema.ts","../src/schematize.ts","../src/ValidationError.ts","../src/mocha.ts","../src/impl/conditional.ts","../src/data.ts","../src/impl/util/functions.ts","../src/schemas.ts"],"sourcesContent":["export type Path = any[];\n\nexport class Problem {\n  constructor(readonly path: Path, readonly message: string) {\n  }\n\n  prefixPath(p: Path): Problem {\n    return new Problem([...p, ...this.path], this.message);\n  }\n\n  toString(): string {\n    return `[${this.path.join(' -> ').trimRight()}] : ${this.message}`\n  }\n}\n\nexport class Problems {\n  constructor(readonly problems: Problem[]) {\n  }\n\n  get length(): number {\n    return this.problems.length;\n  }\n\n  prefixPath(p: Path): Problems {\n    return new Problems(this.problems.map(e => e.prefixPath(p)));\n\n  }\n\n  merge(...ps: Problems[]): Problems {\n    return ps.reduce((acc: Problems, next: Problems) => acc.append(...next.problems), this);\n\n  }\n\n  append(...ps: Problem[]): Problems {\n    return new Problems([...this.problems, ...ps]);\n\n  }\n\n  toString(): string {\n    return this.problems.map(e => e.toString()).join('\\r\\n')\n  }\n}\n\nexport function isError(x: ValidationResult<any>): x is Problems {\n  return x != null && x instanceof Problems;\n}\n\nexport function isSuccess<T>(x: ValidationResult<T>): x is T {\n  return !isError(x);\n}\n\nexport function problem(message: string, path: Path = []) {\n  return new Problem(path, message);\n}\n\nexport function problems(...ps: Problem[]): Problems {\n  return new Problems(ps);\n}\n\nexport function failure(message: string, path: Path = []): Problems {\n  return problems(problem(message, path)) as Problems;\n}\n\nexport interface ValidationErrorOpts {\n  readonly message: string,\n  readonly leakActualValuesInError: boolean,\n}\n\nexport type ValidationResult<T> = Problems | T;","import {Behaviour, Problems, Schema, usingBehaviour, ValidationError, ValidationResult} from \"./impl\";\n\nexport interface ValidationOpts extends Behaviour {\n  message: string;\n}\n\nexport function validate<IN, OUT>(\n  schema: Schema<IN, OUT>,\n  value: IN,\n  opts: Partial<ValidationOpts> = {})\n  : OUT {\n\n  const conformed = conform(schema, value, opts);\n  if (conformed instanceof Problems) {\n    throw new ValidationError(value, conformed, opts);\n  }\n  return conformed;\n}\n\nexport function conform<IN, OUT>(\n  schema: Schema<IN, OUT>,\n  value: IN,\n  opts: Partial<ValidationOpts> = {})\n  : ValidationResult<OUT> {\n\n  if (!schema)\n    throw new Error(\"No schema provided\");\n\n  return usingBehaviour(opts, () => schema.conform(value));\n}\n\n","export type PrimitiveValue = string | number | boolean;\n\nexport function isPrimitive(value: any): boolean {\n  return (typeof value !== 'object' && typeof value !== 'function') || value === null\n}\n\nexport function unsafeCast<T>(x: any): T {\n  return x as T;\n}\n\nexport function typeDescription(x: any): string {\n  if (x === null)\n    return 'null';\n\n  let t = typeof x;\n  if (t !== 'object') return t;\n\n  const p = Object.getPrototypeOf(x);\n  if (p !== Object.prototype)\n    return p.constructor.name;\n\n  return t\n}\n\nexport type Constructor<T = any> = new(...args: any[]) => T ;","import {conform} from \"../helpers\";\nimport {failure, isError, isSuccess, Problems, ValidationResult} from \"../problems\";\nimport {Schema} from \"../schema\";\nimport {subSchemaJson} from \"./\";\nimport {typeDescription} from \"./util/types\";\n\nexport abstract class BaseSchema<IN = any, OUT = any> implements Schema<IN, OUT> {\n\n  or<NEWOUT>(s: Schema<IN, NEWOUT>): Schema<IN, OUT | NEWOUT> {\n    return new OrSchema<IN, OUT | NEWOUT>([this, s]);\n  }\n\n  and<NEWOUT>(s: Schema<OUT, NEWOUT>): Schema<IN, NEWOUT> {\n    return new AndSchema([this, s])\n  }\n\n  __<FAKED extends OUT>(): FAKED {\n    return this as any as FAKED;\n  }\n\n  abstract conform(value: IN): ValidationResult<OUT>;\n\n  abstract toJSON(toJson?: (s: Schema) => any): any;\n\n\n}\n\nexport class AndSchema<IN, OUT> extends BaseSchema<IN, OUT> {\n  constructor(private readonly subSchemas: Schema[]) {\n    super();\n  }\n\n  conform(value: IN): ValidationResult<OUT> {\n    return this.subSchemas.reduce((result, schema) => {\n      if (isError(result))\n        return result;\n      return conform(schema, result);\n    }, value);\n  }\n\n  and<NEWOUT>(s: Schema<OUT, NEWOUT>): Schema<IN, NEWOUT> {\n    return s instanceof AndSchema\n      ? new AndSchema([...this.subSchemas, ...s.subSchemas])\n      : new AndSchema([...this.subSchemas, s])\n  }\n\n  toJSON(toJson?: (s: Schema) => any) {\n    return {\n      allOf: subSchemaJson(this.subSchemas,toJson)\n    };\n  }\n}\n\nexport class OrSchema<IN, OUT> extends BaseSchema<IN, OUT> {\n  constructor(private readonly subSchemas: Schema<IN, OUT>[]) {\n    super();\n  }\n\n  conform(value: IN): ValidationResult<OUT> {\n    const failures: Problems[] = [];\n    for (const s of this.subSchemas) {\n      const result = s.conform(value);\n\n      if (isSuccess(result)) return result;\n\n      failures.push(result as Problems);\n    }\n    return failures.reduce((a: Problems | null, ps: Problems) => a ? a.merge(ps) : ps);\n  }\n\n\n  or<NEWOUT>(s: Schema<IN, NEWOUT>): Schema<IN, OUT | NEWOUT> {\n    return s instanceof OrSchema\n      ? new OrSchema<IN, OUT | NEWOUT>([...this.subSchemas, ...s.subSchemas])\n      : new OrSchema<IN, OUT | NEWOUT>([...this.subSchemas, s])\n  }\n\n  toJSON(toJson?: (s: Schema) => any) {\n    return {\n      anyOf: subSchemaJson(this.subSchemas, toJson)\n    }\n  }\n\n}\n\nexport abstract class BaseStringSchema extends BaseSchema<any, string> {\n  conform(value: any): ValidationResult<string> {\n    if (typeof value === 'string' || value instanceof String)\n      return this.conformString(value as string);\n    return failure(`expected a string but got ${typeDescription(value)}`);\n  }\n\n  abstract conformString(value: string): ValidationResult<string>;\n\n  toJSON(): any {\n    return {type: \"string\"}\n  }\n}\n\nexport class StringSchema extends BaseStringSchema {\n  conformString(value: string): ValidationResult<string> {\n    return value;\n  }\n}\n\n\nexport class DelegatingSchema<IN, OUT> extends BaseSchema<IN, OUT> {\n  constructor(private readonly delegatedConform: (value: IN) => Problems | OUT,\n              public readonly toJSON: () => any = () => {\n                throw new Error('toJSON not implemented')\n              }) {\n    super();\n  }\n\n  conform(value: IN): ValidationResult<OUT> {\n    return this.delegatedConform(value);\n  }\n}\n\nexport function isSchema(value: any): value is Schema {\n  // TODO: probably wrong?\n  return value instanceof BaseSchema;\n}","export function mapKeyValue<K, V, NEWK, NEWV>(f: (k: K, v: V) => [NEWK, NEWV], m: Map<K, V>): Map<NEWK, NEWV> {\n  const result = new Map<NEWK, NEWV>();\n  for (const [k, v] of m.entries()) {\n    const [nk, nv] = f(k, v);\n    result.set(nk, nv);\n  }\n  return result;\n}\n\nexport function mapValues<K, V, NEWV>(f: (v: V) => NEWV, m: Map<K, V>): Map<K, NEWV> {\n  return mapKeyValue((k, v) => [k, f(v)], m);\n}\n\nexport function merge<K, V>(a: Map<K, V>, b: Map<K, V>, conflictFn: (a: V, b: V) => V): Map<K, V> {\n  const result = new Map<K, V>();\n  for (const [k, v] of a.entries()) {\n    result.set(k, v);\n  }\n  for (const [k, v] of b.entries()) {\n    if (result.has(k)) {\n      result.set(k, conflictFn(a.get(k)!, v));\n    }\n    else {\n      result.set(k, v);\n    }\n  }\n  return result;\n}\n\nexport function toMap<K, V>(x: {}): Map<K, V> {\n  const result = new Map<K, V>();\n  for (let [k, v] of Object.entries(x)) {\n    result.set(\n      k as any as K,\n      v as any as V);\n  }\n  return result;\n}","import {DataSchema} from \"./data\";\nimport {isSchema} from \"./impl\";\nimport {merge} from \"./impl/util/maps\";\nimport {Schema, SchemaDefinitions} from \"./schema\";\n\nexport function subSchemaJson(schema: Schema | Schema[], toJson?: (s: Schema) => any): any {\n  toJson = toJson || ((s: Schema) => s.toJSON());\n  return Array.isArray(schema)\n    ? schema.map(toJson)\n    : toJson(schema);\n}\n\nfunction refLookup(defs: SchemaDefinitions, path: string = \"#/definitions\"): Map<Schema, object> {\n  return Object.entries(defs)\n    .reduce((result, [k, schemaOrDefs]) => {\n      const itemPath = `${path}/${k}`;\n      if (isSchema(schemaOrDefs)) {\n        if (schemaOrDefs instanceof DataSchema)\n          schemaOrDefs = schemaOrDefs.subSchema;\n        result.set(schemaOrDefs, {$ref: itemPath});\n        return result;\n      }\n      else {\n        const lookup = refLookup(schemaOrDefs, itemPath);\n        return merge(result, lookup, () => {\n          throw new Error('Should never happen')\n        });\n      }\n\n    }, new Map<Schema, object>());\n\n}\n\nfunction definitionsJson(defs: SchemaDefinitions, toJson: (s: Schema) => any): object {\n  return Object.entries(defs)\n    .reduce((result, [k, schemaOrDefs]) => {\n      if (isSchema(schemaOrDefs))\n        result[k] = schemaOrDefs.toJSON(toJson);\n      else\n        result[k] = definitionsJson(schemaOrDefs, toJson);\n      return result;\n    }, {});\n\n}\n\nexport interface JsonSchemaOpts {\n  id?: string,\n  definitions: SchemaDefinitions;\n}\n\nexport function jsonSchema(opts: JsonSchemaOpts) {\n  const lookup = refLookup(opts.definitions);\n\n  function subschema(schema: Schema): any {\n    if (schema instanceof DataSchema)\n      schema = schema.subSchema;\n    const ref = lookup.get(schema);\n    const result = ref || schema.toJSON(subschema);\n    return result;\n  }\n\n  const definitions = definitionsJson(opts.definitions, subschema);\n\n  return {\n    ...(opts.id && {id: opts.id}),\n    $schema: \"http://json-schema.org/draft-07/schema#\",\n    definitions,\n  };\n}","import {conform} from \"../../helpers\";\nimport {ValidationResult} from \"../../problems\";\nimport {Schema} from \"../../schema\";\nimport {BaseSchema} from \"../core\";\nimport {subSchemaJson} from \"../../jsonSchema\";\n\nexport enum UnexpectedItemBehaviour {\n  DELETE = \"delete\",\n  IGNORE = \"ignore\",\n  PROBLEM = \"problem\"\n}\n\nexport enum MissingItemBehaviour {\n  IGNORE = \"ignore\",\n  PROBLEM = \"problem\"\n}\n\nexport interface Behaviour {\n  readonly unexpected: UnexpectedItemBehaviour;\n  readonly missing: MissingItemBehaviour;\n  readonly leakActualValuesInError: boolean;\n}\n\nlet BEHAVIOUR: Behaviour = {\n  unexpected: UnexpectedItemBehaviour.PROBLEM,\n  missing: MissingItemBehaviour.PROBLEM,\n  leakActualValuesInError: false,\n};\n\nexport function behaviour(): Behaviour {\n  return BEHAVIOUR;\n}\n\nexport function usingBehaviour<T>(behaviour: Partial<Behaviour>, fn: () => T): T {\n  const old = BEHAVIOUR;\n  BEHAVIOUR = Object.assign({}, old, behaviour);\n  try {\n    return fn();\n  }\n  finally {\n    BEHAVIOUR = old;\n  }\n}\n\nexport class BehaviourSchema<IN, OUT> extends BaseSchema<IN, OUT> {\n  constructor(\n    private readonly behaviour: Partial<Behaviour>,\n    private readonly subSchema: Schema<IN, OUT>) {\n    super();\n  }\n\n  conform(value: IN): ValidationResult<OUT> {\n    return usingBehaviour(\n      this.behaviour,\n      () => conform(this.subSchema, value));\n  }\n\n  toJSON(toJson?: (s: Schema) => any): any {\n    return {\n      ...subSchemaJson(this.subSchema, toJson),\n      additionalProperties: this.behaviour.unexpected !== UnexpectedItemBehaviour.PROBLEM\n    };\n  }\n}","import {\n  BaseSchema,\n  behaviour,\n  failure,\n  isError,\n  MissingItemBehaviour,\n  Problems,\n  Schema,\n  subSchemaJson,\n  UnexpectedItemBehaviour,\n  ValidationResult\n} from \"../\";\n\nexport interface Associative<K, V> {\n  set(k: K, v: V): this;\n\n  delete(k: K): boolean;\n\n  has(k: K): boolean;\n\n  get(k: K): any;\n\n  keys(): Iterable<K>;\n}\n\nexport function conformInPlace<K, V>(thing: Associative<K, V>,\n                                     itemSchemas: Iterable<[K, Schema]>): Problems | undefined {\n\n  let problems = new Problems([]);\n  const unmatchedThingKeys = new Set(thing.keys());\n  const {unexpected, missing} = behaviour();\n  for (const [k, s] of itemSchemas) {\n    const v: ValidationResult<any> = s.conform(thing.get(k));\n\n    if (isError(v) && !thing.has(k)) {\n      if (s[optional] !== true && missing !== MissingItemBehaviour.IGNORE) {\n        problems = problems.merge(failure(\"No value\", [k]));\n      }\n      continue;\n    }\n    unmatchedThingKeys.delete(k);\n\n    if (isError(v)) {\n      problems = problems.merge((v as Problems).prefixPath([k]));\n    } else if (v !== undefined) {\n      thing.set(k, v);\n    }\n  }\n\n  for (const k of unmatchedThingKeys) {\n    switch (unexpected) {\n      case UnexpectedItemBehaviour.IGNORE:\n        break;\n      case UnexpectedItemBehaviour.DELETE:\n        thing.delete(k);\n        break;\n      case UnexpectedItemBehaviour.PROBLEM:\n        problems = problems.merge(failure(\"Unexpected item\", [k]));\n        break;\n      default:\n        throw new Error(`Not implemented- ${unexpected}`);\n    }\n  }\n\n  return problems.length > 0 ? problems : undefined;\n}\n\nexport const optional = Symbol(\"optional\");\n\nexport class TagSchemaAsOptional<IN, OUT> extends BaseSchema<IN, OUT | undefined> {\n  [optional] = true;\n\n  constructor(private readonly subschema: Schema<IN, OUT>) {\n    super();\n  }\n\n  conform(value: IN): Problems | OUT | undefined {\n    return value === undefined ? undefined : this.subschema.conform(value);\n  }\n\n  toJSON(toJson?: (s: Schema) => any): any {\n    return subSchemaJson(this.subschema, toJson)\n  }\n\n}\n\nexport function isOptional(schema: Schema): boolean {\n  return schema[optional];\n}\n\nexport type StrictPatternItem<T> = StrictPattern<T> | Schema<any, T> | T\nexport type StrictPattern<T> = { readonly [K in keyof T]: StrictPatternItem<T[K]> };\n\nexport type PatternItem<T> = Pattern<T> | Schema<any, T> | T\nexport type Pattern<T> = { readonly [K in keyof T]?: PatternItem<T[K]> };","import {\n  Associative,\n  BaseSchema,\n  conformInPlace,\n  failure,\n  ObjectSchema,\n  Schema,\n  subSchemaJson,\n  ValidationResult\n} from \"../\";\nimport {typeDescription} from \"../util/types\";\n\nexport class MapSchema<K, V> extends BaseSchema<any, Map<K, V>> {\n  constructor(private readonly subSchema: ObjectSchema<any>) {\n    super();\n  }\n\n  conform(value: any): ValidationResult<Map<K, V>> {\n    if (value === undefined || value === null)\n      return failure('no value');\n\n    if (!(value instanceof Map || typeof value === 'object'))\n      return failure(`expected a Map or object but got ${typeDescription(value)}`);\n\n    const instance = new Map<K, V>();\n    const kvs = value instanceof Map ? value.entries() : Object.entries(value);\n    for (let [k, v] of kvs) {\n      instance.set(k, v);\n    }\n    const problems = conformInPlace(\n      instance as any as Associative<K, V>,\n      this.subSchema.fieldSchemaArray as any);\n    return problems ? problems : instance;\n  }\n\n  toJSON(toJson?: (s: Schema) => any): any {\n    return subSchemaJson(this.subSchema, toJson);\n  }\n}\n\n\n\n","export function addGetter<T, K extends keyof T>(obj: T, k: K, getter: () => T[K]): T {\n  Object.defineProperty(obj, k, {\n    enumerable: true,\n    configurable: true,\n    get: getter\n  });\n  return obj;\n}\n\nexport type GetterMapper<A, B extends { [K in keyof A]: B[K] }> = <K extends keyof A>(original: A, mapped: B, k: K) => () => B[K];\n\nexport function mapGetters<A, B extends { [K in keyof A]: B[K] }>(original: A, mapper: GetterMapper<A, B>): B {\n  return Object\n    .keys(original)\n    .reduce((mapped, k) => addGetter(mapped, k as any, mapper(original, mapped, k as keyof A)), <B>{});\n}\n\nexport function copyGetters<T>(original: T): T {\n  return Object\n    .keys(original)\n    .reduce((mapped, k) => addGetter(mapped, k as any, () => original[k]),\n      <T>{});\n}\n\nexport function merge<A extends object, B extends object>(a: A, b: B, conflictFn: (a, b) => any): A & B {\n  const result = {};\n  for (const k in a) {\n    result[k.toString()] = a[k];\n  }\n  for (const k in b) {\n    if (k in result) {\n      const kk = k as any as keyof A & keyof B;\n      result[k.toString()] = conflictFn(a[kk], b[kk]);\n    }\n    else {\n      result[k.toString()] = b[k];\n    }\n  }\n  return result as any as A & B;\n}","import {\n  Associative,\n  BaseSchema,\n  conformInPlace,\n  EqualsSchema,\n  failure,\n  isOptional,\n  Pattern,\n  PatternItem,\n  RegExpSchema,\n  Schema,\n  StrictPattern, subSchemaJson,\n  TupleSchema,\n  ValidationResult\n} from \"../\";\nimport {addGetter, copyGetters, merge} from \"../util/magic\";\n\nexport function objectEntries(object: object): [string, Schema][] {\n  const result: [string, Schema][] = [];\n  for (const k of Object.keys(object)) {\n    const s = object[k];\n    if (typeof s['conform'] !== 'function')\n      throw new Error(`Not a schema ${s}`);\n    else\n      result.push([k, s]);\n  }\n  return result;\n}\n\nexport function patternItemToSchema<T>(item: PatternItem<T>): Schema {\n  if (typeof item !== 'object')\n    return new EqualsSchema(item);\n\n  if (item instanceof Array)\n    return new TupleSchema(item.map(v => patternItemToSchema(v)));\n\n  if (typeof item === 'undefined')\n    return new EqualsSchema(undefined);\n\n  if (item === null)\n    return new EqualsSchema(null);\n\n  if (typeof item['conform'] === 'function')\n    return item as Schema;\n\n  return new ObjectSchema(item as Pattern<T>);\n}\n\nexport function patternToSchemas<T extends object>(pattern: Pattern<T>): { [K in keyof T]: Schema<T[K]> } {\n\n  const result = {};\n  for (const k of Object.keys(pattern)) {\n    const s = pattern[k];\n    result[k] = patternItemToSchema(s);\n  }\n  return result as any;\n}\n\nexport class ObjectStrategies implements Associative<string, any> {\n  constructor(public readonly result: any) {\n  }\n\n  set(k: any, v: any): this {\n    addGetter(this.result, k, () => v);\n    return this\n  }\n\n  delete(k: any): boolean {\n    return delete this.result[k];\n  }\n\n  has(k: any): boolean {\n    return k in this.result;\n  }\n\n  get(k: any): any {\n    return this.result[k];\n  }\n\n  keys(): Iterable<string> {\n    return Object.keys(this.result);\n  }\n}\n\nexport class ObjectSchema<T extends object> extends BaseSchema<any, T> {\n  public readonly fieldSchemaArray: [string, Schema][];\n\n  constructor(public readonly pattern: Pattern<T>) {\n    super();\n    this.fieldSchemaArray = objectEntries(patternToSchemas(pattern));\n  }\n\n  conform(value: any): ValidationResult<T> {\n    if (value === undefined || value === null)\n      return failure('no value');\n\n    if (typeof value !== 'object')\n      return failure(`expected an object but got ${typeof value}`);\n\n    const instance = copyGetters(value);\n    return this.conformInPlace(instance) as T;\n  }\n\n  /**\n   * Required to allow @hasSchema to conform 'this'\n   */\n  conformInPlace(instance: {}): ValidationResult<{}> {\n    const problems = conformInPlace(\n      new ObjectStrategies(instance),\n      this.fieldSchemaArray);\n\n    return problems ? problems : instance;\n  }\n\n  intersect<U extends object>(other: ObjectSchema<U>): ObjectSchema<T & U> {\n    const mergedSchemas = merge(this.pattern, other.pattern, (a: Schema, b: Schema) => a.and(b)) as StrictPattern<T & U>;\n    return new ObjectSchema<T & U>(mergedSchemas);\n  }\n\n  toJSON(toJson?: (s: Schema) => any): any {\n    const properties = this.fieldSchemaArray.reduce((result, [k, subSchema]) => {\n      result[k] = subSchemaJson(subSchema,toJson);\n      return result;\n    }, {});\n\n    const required = this.fieldSchemaArray\n      .filter(([k, schema]) => !isOptional(schema))\n      .map(([k]) => k);\n\n    return {\n      type: \"object\",\n      properties: properties,\n      required: required,\n    }\n  }\n}\n\n\n\n","import {BaseSchema, conformInPlace, failure, ObjectStrategies, Schema, subSchemaJson, ValidationResult} from \"../\";\n\nexport class ObjOfSchema<T> extends BaseSchema<any, { [k: string]: T }> {\n  constructor(private readonly valueSchema: Schema<any, T>) {\n    super()\n  }\n\n  conform(value: any): ValidationResult<{ [p: string]: T }> {\n    if (value === undefined || value === null)\n      return failure('no value');\n\n    if (typeof value !== 'object')\n      return failure(`expected an object but got ${typeof value}`);\n\n    const itemSchemas = Object.keys(value).map(k => [k, this.valueSchema] as [string, Schema<any, T>]);\n    const instance = <{ [p: string]: T }>{};\n    Object.assign(instance, value);\n    const problems = conformInPlace(new ObjectStrategies(instance), itemSchemas);\n    return problems ? problems : instance;\n  }\n\n  toJSON(toJson?: (s: Schema) => any): any {\n    return {\n      type: \"object\",\n      patternProperties: {\n        \".*\": subSchemaJson(this.valueSchema, toJson)\n      }\n    }\n  }\n}","import {Associative, BaseSchema, conformInPlace, failure, Schema, subSchemaJson, ValidationResult} from \"../\";\nimport {typeDescription} from \"../util/types\";\n\nexport class TupleStrategies<T extends any[]> implements Associative<number, any> {\n  private readonly deleted: number[] = [];\n\n  constructor(private readonly resultIn: T) {\n\n  }\n\n  get result(): T {\n    return Array.from(this.keys()).filter(n => this.deleted.indexOf(n) < 0).map(n => this.resultIn[n]) as T;\n  }\n\n  set(k: number, v: any): this {\n    this.resultIn[k] = v;\n    return this;\n  }\n\n  has(k: number): boolean {\n    return k < this.resultIn.length;\n  }\n\n  get(k: number): any {\n    return this.resultIn[k];\n  }\n\n  delete(k: number): boolean {\n    if (this.resultIn.length <= k) return false;\n    this.deleted.push(k);\n    return true;\n  }\n\n  keys(): Iterable<number> {\n    return Array(this.resultIn.length).keys();\n  }\n}\n\nexport class TupleSchema<T extends any[]> extends BaseSchema<T> {\n  private readonly itemSchemas: [number, Schema][];\n\n  constructor(schemas: Schema[]) {\n    super();\n    this.itemSchemas = schemas.map((v, i) => [i, v] as [number, Schema]);\n  }\n\n  conform(value: any): ValidationResult<T> {\n    if (value === undefined || value === null)\n      return failure('no value');\n\n    if (!(value instanceof Array))\n      return failure(`expected an array but got ${typeDescription(value)}`);\n\n    const instance = [] as any as T;\n    for (let i = 0; i < value.length; i++) {\n      instance[i] = value[i];\n    }\n    const result = new TupleStrategies(instance);\n    const problems = conformInPlace(result, this.itemSchemas);\n    return problems ? problems : result.result;\n  }\n\n  toJSON(toJson?: (s: Schema) => any): any {\n    return {\n      type: \"array\",\n      items: subSchemaJson(this.itemSchemas.map(([k, v]) => v), toJson)\n    }\n  }\n}","import {Associative, ObjectStrategies, TupleStrategies} from \"../\";\n\nexport function wrapAssociative(actual: any): Associative<any, any> {\n  if (actual instanceof Array)\n    return new TupleStrategies(actual);\n  if (typeof actual === 'object')\n    return new ObjectStrategies(actual);\n  throw new Error(`Not supported: ${typeof actual}`);\n}\n\nexport function empty(actual: any): any {\n  if (actual instanceof Array)\n    return [];\n  if (typeof actual === 'object')\n    return {};\n  throw new Error(`Not supported: ${typeof actual}`);\n}","export function first<T>(coll: Iterable<T>): T | undefined {\n  // noinspection LoopStatementThatDoesntLoopJS\n  for (const v of coll) {\n    return v;\n  }\n}","import {EqualsSchema, Schema, schemaOf} from \"../\";\nimport {first} from \"../util/iterables\";\nimport {mapKeyValue} from \"../util/maps\";\nimport {Constructor, isPrimitive, PrimitiveValue, unsafeCast} from \"../util/types\";\n\nclass CandidateDiscriminators<T extends object> {\n  private readonly constructors: Constructor<T>[] = [];\n  private readonly fields = new Map<keyof T, Map<PrimitiveValue, Constructor<T>[]>>();\n\n  constructor(ctors: Constructor<T>[]) {\n    this.constructors = [...ctors];\n    for (const ctor of this.constructors) {\n      for (const [fieldName, value] of CandidateDiscriminators.fieldsWithPrimitiveEquals(ctor)) {\n        const result = this.fields.get(fieldName) || new Map();\n        result.set(value, (result.get(value) || []).concat([ctor]));\n        this.fields.set(fieldName, result)\n      }\n    }\n  }\n\n  private static fieldsWithPrimitiveEquals<T extends object>(ctor: Constructor<T>): [keyof T, PrimitiveValue][] {\n    return CandidateDiscriminators.fieldSchemas(ctor)\n      .map(([field, schema]) => schema instanceof EqualsSchema && isPrimitive(schema.expected) ? [field, schema.expected] : undefined)\n      .filter((x) => x)\n      .map((x) => unsafeCast(x))\n  }\n\n  private static fieldSchemas<T extends object>(ctor: Constructor<T>): [string, Schema<any, any>][] {\n    return schemaOf(ctor).fieldSchemaArray;\n  }\n\n  keys(): IterableIterator<keyof T> {\n    return this.fields.keys();\n  }\n\n  get(field: keyof T): Map<PrimitiveValue, Constructor<T>[]> | undefined {\n    return this.fields.get(field);\n  }\n\n  problemWithDiscriminator(field: keyof T): string | undefined {\n    const values = this.fields.get(field)!;\n    for (const [value, ctors] of values) {\n      if (ctors.length > 1)\n        return `value '${value}' is repeated in: ${ctors.map((c) => c.name).join(\", \")}`;\n    }\n    if (values.size !== this.constructors.length)\n      return 'field is not present in all classes';\n  }\n\n\n}\n\nclass DiscriminatorReport<T> {\n  public readonly problems = new Map<keyof T, string>();\n  public readonly validFields = new Map<keyof T, Map<PrimitiveValue, Constructor<T>>>();\n\n  reject(k: keyof T, problem: string): this {\n    this.problems.set(k, problem);\n    return this;\n  }\n\n  accept(k: keyof T, mappings: Map<PrimitiveValue, Constructor<T>>): this {\n    this.validFields.set(k, mappings);\n    return this;\n  }\n}\n\nexport function detectDiscriminator<T extends object>(ctors: Constructor<T>[]): keyof T {\n  const report = discriminatorReports(ctors);\n\n  if (report.validFields.size > 1)\n    throw new Error(`Multiple possible discriminator fields: [${Array.from(report.validFields.keys()).join(', ')}]`);\n\n  if (report.validFields.size === 0 && report.problems.size === 0)\n    throw new Error(`No discriminator fields found in: [${ctors.map((c) => c.name).join(', ')}]`);\n\n  const k = first(report.validFields.keys());\n  if (k !== undefined) {\n    return k;\n  }\n\n  const listOfFieldProblems = Array.from(report.problems.entries()).map(([k, problem]) => `${k}: ${problem}`);\n  throw new Error(`No discriminator field found. Considered:\\r\\n${listOfFieldProblems.join('\\r\\n')}`);\n}\n\nexport function discriminatorReports<T extends object>(ctors: Constructor<T>[]): DiscriminatorReport<T> {\n  const candidates = new CandidateDiscriminators<T>(ctors);\n  const report = new DiscriminatorReport<T>();\n  for (const k of candidates.keys()) {\n    const problem = candidates.problemWithDiscriminator(k);\n    if (problem !== undefined)\n      report.reject(k, problem);\n    else\n      report.accept(k, mapKeyValue((k: PrimitiveValue, v: Constructor<T>[]) => [k, v[0]], candidates.get(k)!))\n  }\n  return report;\n}","import {BaseSchema, subSchemaJson} from \"../\";\nimport {DataSchema} from \"../../data\";\nimport {failure, Problems} from \"../../problems\";\nimport {Schema} from \"../../schema\";\nimport {mapValues} from \"../util/maps\";\nimport {Constructor, PrimitiveValue} from \"../util/types\";\nimport {discriminatorReports} from \"./find_discriminators\";\n\nexport class DiscriminatedUnionSchema<T extends object> extends BaseSchema<any, T> {\n  private readonly discriminator: keyof T;\n  private readonly schemasByDiscriminatorValue: Map<PrimitiveValue, Schema<any, T>>;\n\n  constructor(private readonly ctors: Constructor<T>[], discriminator: keyof T) {\n    super();\n\n    this.discriminator = discriminator;\n\n    const report = discriminatorReports(ctors);\n    const schemasByValue = report.validFields.get(this.discriminator);\n    if (schemasByValue === undefined)\n      throw new Error(`Discriminator '${discriminator}' is not valid: ${report.problems.get(discriminator) || 'not found in classes'}.`);\n\n    this.schemasByDiscriminatorValue = mapValues((v) => new DataSchema(v), schemasByValue);\n  }\n\n  conform(value: object): Problems | T {\n    if (typeof value !== 'object')\n      return failure(`expected an object but got ${typeof value}`);\n\n    if (!(this.discriminator in value))\n      return failure(\n        \"no value\",\n        [this.discriminator]);\n\n    const schema = this.schemaFor(value);\n    if (schema === undefined)\n      return failure(\n        `expected one of [${Array.from(this.schemasByDiscriminatorValue.keys()).join(\", \")}]`,\n        [this.discriminator]);\n\n    return schema.conform(value);\n  }\n\n\n  or<NEWIN extends any, NEWOUT>(that: Schema<any, NEWOUT>): Schema<any, T | NEWOUT> {\n    if (that instanceof DiscriminatedUnionSchema\n      && this.discriminator === that.discriminator) {\n      try {\n        // This will give much better error messages, if it's possible\n        // to combine the schemas.\n        return new DiscriminatedUnionSchema(\n          [...this.ctors, ...that.ctors],\n          this.discriminator)\n      } catch (e) {\n        //lean on constructor validation logic\n      }\n    }\n\n    return super.or(that);\n\n  }\n\n  private schemaFor(value: object): Schema<any, T> | undefined {\n    const discriminatorValue = value[this.discriminator as string | symbol];\n    return this.schemasByDiscriminatorValue.get(discriminatorValue);\n  }\n\n  toJSON(toJson?: (s: Schema) => any): any {\n    const allOf: object[] = [];\n    for (const [v, schema] of this.schemasByDiscriminatorValue.entries()) {\n      allOf.push({\n        if: {properties: {[this.discriminator]: {const: v}}},\n        then: subSchemaJson(schema, toJson),\n      })\n    }\n    return {\n      type: \"object\",\n      properties: {\n        [this.discriminator]: true\n      },\n      allOf\n    }\n  }\n}\n\n","import {BaseSchema, failure, Problems, Schema, subSchemaJson, ValidationResult} from \"./\";\nimport {typeDescription} from \"./util/types\";\n\nexport class ArrayOfSchema<T> extends BaseSchema<any[], T[]> {\n  constructor(private readonly itemSchema: Schema<any, T>) {\n    super();\n  }\n\n  conform(value: any): ValidationResult<T[]> {\n    if (!(value instanceof Array))\n      return failure(`${typeDescription(value)} was not an Array`);\n\n    const conformed: T[] = new Array(value.length);\n    let problems = new Problems([]);\n    for (let i = 0; i < value.length; i++) {\n      const conformedItem = this.itemSchema.conform(value[i]);\n      if (conformedItem instanceof Problems)\n        problems = problems.merge(conformedItem.prefixPath([i]));\n      else\n        conformed[i] = conformedItem\n    }\n    if (problems.length > 0)\n      return problems;\n\n    return conformed;\n  }\n\n  toJSON(toJson?: (s: Schema) => any): any {\n    return {\n      type: \"array\",\n      contains: subSchemaJson(\n        this.itemSchema,\n        toJson),\n    }\n  }\n}","import {BaseSchema, failure, ValidationResult} from \"./\";\n\nexport class BooleanSchema extends BaseSchema<any, boolean> {\n  conform(value: any): ValidationResult<boolean> {\n    const t = typeof value;\n    if (value instanceof Boolean || t === \"boolean\")\n      return value;\n\n    if (value instanceof String || t === \"string\") {\n      const s: string = value.toLowerCase();\n      if ([\"true\", \"false\"].indexOf(s) < 0)\n        return failure(`expected a boolean`);\n      return s === 'true';\n    }\n    return failure(`expected a boolean`);\n  }\n\n  toJSON(): any {\n    return {type: \"boolean\"}\n  }\n}","export function toJSON(value: any): any {\n  if (Array.isArray(value))\n    return value.map(v => toJSON(v));\n  if (typeof value === \"object\")\n    return typeof value['toJSON'] === 'function' ? value.toJSON() : value;\n  return value;\n}","import {BaseSchema, optional, Schema, subSchemaJson, ValidationResult} from \"./\";\nimport {toJSON} from \"./util/json\";\n\nexport class DefaultValueSchema<T> extends BaseSchema<any, T> {\n  [optional]: true;\n\n  constructor(private readonly value: () => T,\n              private readonly subschema: Schema<any, T>) {\n    super()\n  }\n\n  conform(value: any): ValidationResult<T> {\n    if (value === undefined)\n      value = this.value();\n\n    return this.subschema.conform(value);\n  }\n\n  toJSON(toJson?: (s: Schema) => any): any {\n    return {\n      ...subSchemaJson(this.subschema, toJson),\n      default: toJSON(this.value()),\n    };\n  }\n}","import {BaseSchema, Schema, subSchemaJson, ValidationResult} from \"./\";\n\nexport class DeferredSchema<IN, OUT> extends BaseSchema<IN, OUT> {\n  private _subschema: Schema<IN, OUT>;\n\n  constructor(private readonly deferred: () => Schema<IN, OUT>) {\n    super();\n  }\n\n  private get subschema(): Schema<IN, OUT> {\n    this._subschema = this.deferred();\n    return this._subschema;\n  }\n\n  conform(value: IN): ValidationResult<OUT> {\n    return this.subschema.conform(value);\n  }\n\n  toJSON(toJson?: (s: Schema) => any): any {\n    return subSchemaJson(this.subschema,toJson);\n  }\n}","import phone from \"phone\";\nimport {BaseSchema, failure, ValidationResult} from \"./\";\nimport {typeDescription} from \"./util/types\";\n\nexport class E164PhoneNumberSchema extends BaseSchema<any, string> {\n  constructor(private readonly defaultCountryIso3166?: string) {\n    super();\n  }\n\n  conform(value: any): ValidationResult<string> {\n\n    if (typeof value !== 'string')\n      return failure(`expected a string but got ${typeDescription(value)}`);\n\n    const result = this.defaultCountryIso3166 ? phone(value, this.defaultCountryIso3166) : phone(value);\n\n    if (result.length === 0) {\n      return failure(`expected a valid E.164 phone number`)\n    } else {\n      return result[0]\n    }\n\n  }\n\n  toJSON(): any {\n    return {\n      type: \"string\",\n      description: \"Phone number\",\n    }\n  }\n}\n","import {typeDescription} from \"./types\";\n\nenum EntryType {\n  StringMember,\n  ReverseMapping,\n  NumericMember,\n  Invalid\n}\n\nexport enum EnumType {\n  InitializedStrings,\n  InitializedIntegers,\n  Mixed\n}\n\nexport function analyseEnum<T>(e: T): { values: Set<any>, type: EnumType } {\n  let allStringMembers = true;\n  let someStringMembers = false;\n  const values = new Set<any>();\n  for (let [k, v] of Object.entries(e) as [string | number, any][]) {\n    if (!isNaN(Number(k)))\n      k = Number(k);\n\n    const valueType: string = typeof v;\n    const keyType: string = typeof k;\n\n    const entryType: EntryType =\n      (keyType === 'string' && valueType === 'string') ? EntryType.StringMember :\n        (keyType === 'string' && valueType === 'number') ? EntryType.NumericMember :\n          (keyType === 'number' && valueType === 'string') ? EntryType.ReverseMapping :\n            EntryType.Invalid;\n\n    if (entryType === EntryType.Invalid)\n      throw new Error(\n        `Entries must be string:number, number:string or string:string. Field '${k}' was ${typeDescription(k)}:${typeDescription(v)}.`);\n\n    if (entryType !== EntryType.StringMember)\n      allStringMembers = false;\n\n    if (entryType !== EntryType.ReverseMapping)\n      values.add(v);\n\n    if (entryType === EntryType.StringMember)\n      someStringMembers = true;\n    else if (e[v.toString()] != k)\n      throw new Error(`Not a proper enum. e[\"${k}\"] = ${JSON.stringify(v)} but e[\"${v}\"] = ${JSON.stringify(e[v])}`);\n  }\n  const type = allStringMembers ? EnumType.InitializedStrings :\n    someStringMembers ? EnumType.Mixed :\n      EnumType.InitializedIntegers;\n\n  return {values, type};\n}","import {BaseSchema, failure, ValidationResult} from \"./\";\nimport {analyseEnum, EnumType} from \"./util/analyseEnum\";\n\n\nexport class EnumValueSchema<T extends object> extends BaseSchema<any, T[keyof T]> {\n  private readonly enumValues: Set<any>;\n  private readonly enumType: EnumType;\n  private failureMessage: string;\n\n  constructor(private readonly e: T) {\n    super();\n    const {values, type} = analyseEnum(this.e);\n\n    this.enumValues = values;\n    this.enumType = type\n\n    this.failureMessage = `expected one of [${Array.from(this.enumValues).map((v) => JSON.stringify(v)).join(', ')}]`;\n  }\n\n  conform(value: any): ValidationResult<T[keyof T]> {\n    if (this.enumValues.has(value))\n      return value;\n\n    return failure(this.failureMessage)\n  }\n\n  toJSON(): any {\n    switch (this.enumType) {\n      case EnumType.InitializedIntegers:\n        return {\n          type: \"number\",\n          enum: [...this.enumValues]\n        };\n      case EnumType.InitializedStrings:\n        return {\n          type: \"string\",\n          enum: [...this.enumValues]\n        };\n      case EnumType.Mixed:\n        return {\n          type: [\"string\", \"number\"],\n          enum: [...this.enumValues]\n        };\n      default:\n        throw new Error(`Enum type ${JSON.stringify(this.enumType)} not supported`);\n    }\n  }\n}","import {BaseSchema, failure, ValidationResult} from \"./\";\nimport {typeDescription} from \"./util/types\";\n\nexport class EqualsSchema<T> extends BaseSchema<any, T> {\n  constructor(public readonly expected: T) {\n    super();\n  }\n\n  conform(value: any): ValidationResult<T> {\n    if (value !== this.expected)\n      return failure(`expected \"${this.expected}\" but got ${typeDescription(value)}: ${JSON.stringify(value)}`);\n    return value;\n  }\n\n  toJSON(): object {\n    return {const: this.expected};\n  }\n\n}","import {BaseSchema, failure, ValidationResult} from \"./\";\nimport {toJSON} from \"./util/json\";\n\nexport class InSchema<T extends number | string | null> extends BaseSchema<any, T> {\n  private readonly values: Set<T>;\n\n  constructor(values: T[]) {\n    super();\n    if(values.length===0)\n      throw new Error('At least one value is required');\n    this.values = new Set(values);\n  }\n\n  conform(value: any): ValidationResult<T> {\n    if (!this.values.has(value))\n      return failure(`expected one of [${Array.from(this.values).join(', ')}]`);\n    return value;\n  }\n\n  toJSON(): any {\n    const values = [...this.values].map(v => toJSON(v));\n    const types = new Set(values.map(v => typeof v));\n\n    return {\n      type: types.size === 1 ? types.values().next().value : [...types],\n      enum: values\n    };\n  }\n}","import {BaseSchema, failure, ValidationResult} from \"./\";\nimport {Constructor, typeDescription} from \"./util/types\";\n\nexport class IsInstanceSchema<T> extends BaseSchema<any, T> {\n  constructor(private readonly c: Constructor<T>) {\n    super();\n  }\n\n  conform(value: any): ValidationResult<T> {\n    return value instanceof this.c ? value : failure(`expected ${this.c.name} but got ${typeDescription(value)}`);\n  }\n\n  /**\n   * This isn't really suitable for json schema,\n   * which doesn't have the concept of a type\n   */\n  toJSON(): any {\n    return {\n      type: \"object\",\n      description: `Instance of ${this.c.name}`,\n      additionalProperties: true,\n    }\n  }\n\n}","export function utcDate(year: number, month: number, date: number, hours?: number, minutes?: number, seconds?: number, ms?: number): Date {\n  const ts = ms ? Date.UTC(year, month, date, hours, minutes, seconds, ms)\n    : seconds ? Date.UTC(year, month, date, hours, minutes, seconds)\n      : minutes ? Date.UTC(year, month, date, hours, minutes)\n        : hours ? Date.UTC(year, month, date, hours)\n          : Date.UTC(year, month, date);\n  return new Date(ts)\n}","import {BaseSchema, failure, ValidationResult} from \"./\";\nimport {utcDate} from \"./util/dates\";\n\nconst regex = /^([1-9][0-9]{3})-([0-1][0-9])-([0-3][0-9])(T([0-2][0-9]):([0-6][0-9])(:([0-6][0-9])(\\.([0-9]{3}))?)?((Z)|(\\+([0-2][0-9]):([0-6][0-9]))))?$/;\n\nexport enum TimeExpectation {\n  NEVER = 'never',\n  ALWAYS = 'always',\n  MAYBE = 'maybe',\n}\n\nexport class IsoUtcDateSchema extends BaseSchema<any, Date> {\n  constructor(private readonly time: TimeExpectation) {\n    super()\n  }\n\n  conform(value: any): ValidationResult<Date> {\n    if (typeof value === 'string') {\n      const match = regex.exec(value);\n      if (!match)\n        return failure(\"expected a valid ISO8601 string\");\n\n      try {\n        const year = Number.parseInt(match[1]);\n        const month = Number.parseInt(match[2]) - 1;\n        const date = Number.parseInt(match[3]);\n\n        if (value.length === 10 && this.time === TimeExpectation.ALWAYS)\n          return failure(\"date should have a time of day component\");\n\n        const hours = match[5] ? Number.parseInt(match[5]) : 0;\n        const minutes = match[6] ? Number.parseInt(match[6]) : 0;\n\n        const seconds = match[8] ? Number.parseInt(match[8]) : 0;\n        const millis = match[10] ? Number.parseInt(match[10]) : 0;\n\n        const offsetHours = match[14] ? Number.parseInt(match[14]) : 0;\n        const offsetMinutes = match[15] ? Number.parseInt(match[15]) : 0;\n\n        if (offsetHours !== 0 || offsetMinutes !== 0)\n          return failure(\"expected a UTC date, with timezone specified as Z or 00:00\");\n\n\n        value = utcDate(\n          year,\n          month,\n          date,\n          hours,\n          minutes,\n          seconds,\n          millis\n        );\n        if (\n          value.getUTCFullYear() !== year ||\n          value.getUTCMonth() !== month ||\n          value.getUTCDate() !== date ||\n          value.getUTCHours() !== hours ||\n          value.getUTCMinutes() !== minutes ||\n          value.getUTCMilliseconds() !== millis\n        ) return failure(\"expected a valid date\");\n      }\n      catch {\n        return failure(\"expected a valid date\")\n      }\n    }\n\n    if (!(value instanceof Date))\n      return failure(\"expected a date or string\");\n\n    if (this.time === TimeExpectation.NEVER && utcDate(value.getUTCFullYear(), value.getUTCMonth(), value.getUTCDate()).getTime() !== value.getTime())\n      return failure(\"date should not have a time of day component\");\n\n    return value;\n  }\n\n  toJSON(): any {\n    return {\n      type: \"string\", format: this.time === TimeExpectation.ALWAYS\n        ? 'date-time'\n        : this.time === TimeExpectation.NEVER\n          ? 'date'\n          : 'date-time'\n    }\n  }\n}","import {BaseSchema, failure, Problems, Schema, SelectSchema, ValidationResult} from \"./\";\n\nexport function setAtPath<T>(obj: T, path: string[], value: any): T {\n  if (path.length === 1) {\n    obj[path[0]] = value;\n    return obj;\n  }\n\n  const key = path[0];\n  setAtPath(obj[key], path.slice(1), value);\n  return obj;\n}\n\nexport class LensSchema<T, U> extends BaseSchema<any, T> {\n  private readonly subschema: Schema<any, U>;\n\n  constructor(private readonly path: string[], subschema: Schema<any, U>) {\n    super();\n    this.subschema = new SelectSchema(path, subschema)\n  }\n\n  conform(value: any): ValidationResult<T> {\n    if (typeof value !== 'object')\n      return failure(\"expected an object\");\n\n    const conformed = this.subschema.conform(value);\n    if (conformed instanceof Problems)\n      return conformed;\n\n    return setAtPath(value, this.path, conformed);\n  }\n\n  toJSON(): any {\n    throw new Error(\"Not implemented\");\n  }\n}\n\nexport enum LensBehaviour {\n  MODIFY_IN_PLACE = 'modify-in-place'\n  // Deep clone is not implemented.\n  // Just a marker enum to flag the behaviour\n}","import {BaseSchema, failure, ValidationResult} from \"./\";\nimport {typeDescription} from \"./util/types\";\n\nexport class LookupSchema<T extends object, V> extends BaseSchema<any, T[keyof T]> {\n  constructor(private readonly lookup: T) {\n    super();\n  }\n\n  conform(value: any): ValidationResult<T[keyof T]> {\n    if (typeof value !== 'string')\n      return failure(`expected a string but got ${typeDescription(value)}`);\n\n    if (value in this.lookup)\n      return this.lookup[value];\n\n    return failure(`expected one of [${Object.keys(this.lookup).map((k) => JSON.stringify(k)).join(', ')}]`)\n  }\n\n  toJSON(): any {\n    return {\n      type: \"string\",\n      enum: Object.keys(this.lookup)\n    }\n  }\n}","import {BaseSchema, failure, problem, Problem, problems, ValidationResult} from \"./\";\n\nexport interface Opts {\n  minimum?: number;\n  exclusiveMinimum?: number;\n  maximum?: number;\n  exclusiveMaximum?: number;\n  multipleOf?: number;\n}\n\nexport class NumberSchema extends BaseSchema<any, number> {\n  constructor(\n    private readonly opts: Opts\n  ) {\n    super();\n  }\n\n  conform(value: any): ValidationResult<number> {\n    if (typeof value !== 'number')\n      return failure('expected a number');\n\n    const {minimum, exclusiveMinimum, maximum, exclusiveMaximum, multipleOf} = this.opts;\n    const p: Problem[] = [];\n\n    if (minimum && !(value >= minimum))\n      p.push(problem(`must be greater than or equal to ${minimum}`));\n\n    if (exclusiveMinimum && !(value > exclusiveMinimum))\n      p.push(problem(`must be greater than ${exclusiveMinimum}`));\n\n    if (maximum && !(value <= maximum))\n      p.push(problem(`must be less than or equal to ${maximum}`));\n\n    if (exclusiveMaximum && !(value < exclusiveMaximum))\n      p.push(problem(`must be less than ${exclusiveMaximum}`));\n\n    if (multipleOf && value % multipleOf !== 0)\n      p.push(problem(`must be multiple of ${multipleOf}`));\n\n    return (p.length > 0)\n      ? problems(...p)\n      : value;\n  }\n\n  toJSON(): any {\n    const {minimum, exclusiveMinimum, maximum, exclusiveMaximum, multipleOf} = this.opts;\n    return {\n      type: \"number\",\n      ...(minimum && {minimum}),\n      ...(exclusiveMinimum && {exclusiveMinimum}),\n      ...(maximum && {maximum}),\n      ...(exclusiveMaximum && {exclusiveMaximum}),\n      ...(multipleOf && {multiple: multipleOf}),\n    }\n  }\n\n}","import {BaseSchema, failure, Problems, Schema, subSchemaJson, ValidationResult} from \"./\";\nimport {typeDescription} from \"./util/types\";\n\nexport interface SchemaOverrides<IN, OUT> {\n  failure?: string | ((value: IN) => Problems);\n}\n\nexport class OverrideSchema<IN, OUT> extends BaseSchema<IN, OUT> {\n  constructor(private readonly subschema: Schema<IN, OUT>,\n              private readonly overrides: SchemaOverrides<IN, OUT>) {\n    super();\n  }\n\n  conform(value: IN): ValidationResult<OUT> {\n    const result = this.subschema.conform(value);\n    return result instanceof Problems\n      ? this.failure(value, result)\n      : result;\n  }\n\n  private failure(value: IN, original: Problems): Problems {\n    const f = this.overrides.failure;\n\n    if (!f) {\n      return original;\n    }\n    else if (typeof f === 'string') {\n      return failure(f)\n    }\n    else if (f instanceof Function) {\n      return f(value);\n    }\n    else {\n      throw new Error(`Not implemented for ${typeDescription(f)}`);\n    }\n  }\n\n  toJSON(toJson?: (s: Schema) => any): any {\n    return subSchemaJson(this.subschema, toJson);\n  }\n}","import {BaseStringSchema, failure, ValidationResult} from \"./\";\n\nexport class RegExpSchema extends BaseStringSchema {\n  constructor(private readonly r: RegExp) {\n    super();\n  }\n\n  conformString(value: string): ValidationResult<string> {\n    return this.r.test(value) ? value : failure(`did not match ${this.r}`);\n  }\n\n  toJSON(): any {\n    return {\n      ...super.toJSON(),\n      pattern: this.r.toString().replace(/^\\//, '').replace(/\\/$/, '')\n    }\n  }\n}","import {BaseSchema, failure, Problems, Schema, ValidationResult} from \"./\";\n\nexport class SelectSchema<T> extends BaseSchema<any, T> {\n  constructor(private readonly path: string[],\n              private readonly subschema: Schema<any, T>) {\n    super()\n  };\n\n  conform(value: any): ValidationResult<T> {\n    if (typeof value !== 'object')\n      return failure(\"expected an object\");\n\n    let target: any = value;\n    let atPath: string[] = [];\n    for (const key of this.path) {\n      atPath.push(key);\n      if (!(key in target))\n        return failure(\"no value\", atPath);\n      target = target[key];\n    }\n    const result = this.subschema.conform(target);\n    return result instanceof Problems\n      ? result.prefixPath(this.path)\n      : result;\n  }\n\n  toJSON(): any {\n    throw new Error(\"Not implemented\");\n  }\n}","import {BaseSchema, failure, Problems, Schema, subSchemaJson, ValidationResult} from \"./\";\nimport {typeDescription} from \"./util/types\";\n\nexport class SetOfSchema<T> extends BaseSchema<any, Set<T>> {\n  constructor(private readonly itemSchema: Schema<any, T>) {\n    super();\n  }\n\n  conform(value: any): ValidationResult<Set<T>> {\n    if (!(value instanceof Set || value instanceof Array))\n      return failure(`${typeDescription(value)} was not an Array or a Set`);\n\n    const entries: Iterable<[any, any]> = value instanceof Set ? value.entries() : value.map((v, i) => [i, v] as [any, any]);\n\n    const conformed = new Set<T>();\n    let problems = new Problems([]);\n    for (const [k, v] of entries) {\n      const c = this.itemSchema.conform(v);\n      if (c instanceof Problems)\n        problems = problems.merge(c.prefixPath([k]));\n      else\n        conformed.add(c);\n    }\n    if (problems.length > 0)\n      return problems;\n\n    return conformed;\n  }\n\n  toJSON(toJson?: (s: Schema) => any): any {\n    return {\n      type: \"array\",\n      items: subSchemaJson(this.itemSchema, toJson)\n    }\n  }\n\n}","import {BaseSchema, failure, problem, Problem, problems, ValidationResult} from \"./\";\nimport {typeDescription} from \"./util/types\";\n\nexport class UniqueSchema<T, V> extends BaseSchema<T[], T[]> {\n  constructor(private readonly keyfn: (t: T) => V) {\n    super()\n  };\n\n  conform(value: any): ValidationResult<T[]> {\n    if (!(value instanceof Array))\n      return failure(`${typeDescription(value)} was not an Array`);\n\n    const countKeys = (m, t, i) => {\n      const k: V = this.keyfn(t);\n      if (!m.has(k))\n        m.set(k, []);\n      // @ts-ignore\n      m.get(k).push(i);\n      return m;\n    };\n\n    const keyCounts: Map<V, number[]> = value.reduce(countKeys, new Map<V, number[]>());\n    const p: Problem[] = [];\n    for (const [k, indexes] of keyCounts.entries()) {\n      if (indexes.length === 1) continue;\n      const message = `duplicate at indexes: [${indexes}]`;\n      const map = indexes.map((i) => problem(message, [i]));\n      p.push(...map)\n    }\n    return p.length > 0 ? problems(...p) : value;\n  }\n\n  toJSON(): any {\n    return {\n      type: \"array\",\n      description: \"unique values\"\n    }\n  }\n}","import validator from \"validator\";\nimport {failure, BaseStringSchema, ValidationResult} from \"./\";\n\nexport interface IsURLOptions {\n  protocols?: string[];\n  require_tld?: boolean;\n  require_protocol?: boolean;\n  require_valid_protocol?: boolean;\n  allow_underscores?: boolean;\n  host_whitelist?: false | (string | RegExp)[];\n  host_blacklist?: false | (string | RegExp)[];\n  allow_trailing_dot?: boolean;\n  allow_protocol_relative_urls?: boolean;\n}\n\nexport class UrlSchema extends BaseStringSchema {\n  constructor(private readonly opts: IsURLOptions) {\n    super();\n  }\n\n  conformString(value: string): ValidationResult<string> {\n    if (validator.isURL(value, this.opts)) return value;\n    return failure(`not a valid url: ${value}`)\n  }\n\n  toJSON(): any {\n    return {...super.toJSON(), format: \"url\"}\n  }\n}","import {failure, RegExpSchema, ValidationResult} from \"./\";\n\nconst REGEX = /^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89ab][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$/;\n\nexport class UuidSchema extends RegExpSchema {\n  constructor() {\n    super(REGEX);\n  }\n\n  conformString(value: string): ValidationResult<string> {\n    const conformed = value.toLowerCase();\n    return REGEX.test(conformed) ? conformed : failure(`not a valid uuid: ${value}`);\n  }\n  toJSON(): any {\n    return {...super.toJSON(), format: \"uuid\"}\n  }\n}","import {isSchema, ObjectSchema, Problems, ValidationError} from \"./impl\";\nimport {Constructor} from \"./impl/util/types\";\n\nconst SCHEMA_SYMBOL = Symbol('schema');\n\nexport function schemaOf<T extends object>(ctor: Constructor<T>): ObjectSchema<T> {\n  for (let search: Function = ctor; search; search = Object.getPrototypeOf(search)) {\n    const pd = Object.getOwnPropertyDescriptor(search, SCHEMA_SYMBOL);\n    if (pd !== undefined)\n      return pd.value;\n  }\n  throw new Error(`No schema on ${ctor.name}- not annotated with @data?`);\n}\n\nlet SUSPEND_VALIDATION = false;\n\nexport function suspendValidation<T>(f: () => T): T {\n  try {\n    SUSPEND_VALIDATION = true;\n    return f();\n  } finally {\n    SUSPEND_VALIDATION = false;\n  }\n}\n\n\n// TODO: add generic constraints to IN/OUT on Schema?\nexport function hasSchema<C extends { new(...args: any[]): object }>(schema: ObjectSchema<C>): (c: C) => C {\n  return function <C extends { new(...args: any[]): object }>(c: C): C {\n    const hackClassName = {};\n    hackClassName[c.name] = class extends c {\n      constructor(...args: any[]) {\n        super(...args);\n        if (SUSPEND_VALIDATION)\n          return;\n\n        for (const [k, v] of Object.entries(this)) {\n          if (isSchema(v))\n            this[k] = undefined;\n        }\n        const conformed = schema.conformInPlace(this);\n        if (conformed instanceof Problems) {\n          throw new ValidationError(this, conformed);\n        }\n      };\n    };\n\n    const decorated = hackClassName[c.name];\n    Object.defineProperty(decorated, SCHEMA_SYMBOL, {value: schema, writable: false});\n    return decorated;\n  }\n}\n\n","import {EqualsSchema, ObjectSchema, StrictPattern} from \"./impl\";\nimport {Schema} from \"./schema\";\n\nexport type Schemaish = Schema<any, any> | Function | number | string | boolean | object;\n\nexport function schematizeEntries<T extends object>(object: Object): StrictPattern<T> {\n  const fixed = <StrictPattern<T>>{};\n  for (const [k, v] of Object.entries(object)) {\n    fixed[k] = schematize(v);\n  }\n  return fixed;\n}\n\ntype LiftObject<T> = T extends object ? T : never;\n\nexport function schematize<IN, OUT>(x: Schemaish): Schema<IN, OUT> {\n  switch (typeof x) {\n    case \"string\":\n    case \"number\":\n    case \"boolean\":\n      return new EqualsSchema(x)  as any as Schema<IN, OUT>;\n\n    case \"object\":\n      const obj = (x as object);\n\n      if ('conform' in obj && typeof x['conform'] === \"function\")\n        return x as Schema<IN, OUT>;\n\n      else if (Object.getPrototypeOf(x) === Object.prototype)\n        return new ObjectSchema<LiftObject<OUT>>(\n          schematizeEntries(obj)) as any as Schema<IN, OUT>;\n      else\n        throw Error(`Cannot build schema from non-plain object ${Object.getPrototypeOf(x).name}`);\n\n    default:\n      throw Error(`Cannot build schema from ${typeof x}: ${x}`);\n  }\n}","import {empty, Path, Problems, ValidationErrorOpts, wrapAssociative} from \"./impl\";\nimport {isPrimitive} from \"./impl/util/types\";\n\nexport function pathsEq(a: Path, b: Path) {\n  return a.length === b.length\n    && a.every((v, i) => v === b[i]);\n}\n\nexport function pathStartsWith(path: Path, startsWith: Path) {\n  return path.length >= startsWith.length\n    && startsWith.every((v, i) => v === path[i]);\n}\n\nfunction intertwingledValue<T>(actual: any, problems: Problems, path: Path): any {\n  if (isPrimitive(actual))\n    return actual;\n\n  // Arrays or objects\n  const associative = wrapAssociative(actual);\n\n  const keys = new Set(associative.keys());\n\n  const missingKeys = problems.problems\n    .filter(p =>\n      // problems for direct children of path (but not ancestors)\n      p.path.length === path.length + 1\n      && pathStartsWith(p.path, path)\n\n      // ...that are not in actual\n      && !keys.has(p.path[-1]))\n    .map(p => p.path[p.path.length - 1]);\n\n  return [...keys, ...missingKeys]\n    .reduce((result, k) => {\n      result[k] = intertwingle(actual[k], problems, [...path, k]);\n      return result;\n    }, empty(actual));\n}\n\n/**\n * Returns an object in the same shape as actual, but with invalid values replaced with an error report.\n *\n * e.g.\n *\n * const actual = {right: 'right', wrong:'wrong'};\n * const problems = [{path: ['wrong'], message: 'error message'};\n * intertwingle(actual, problems);\n *\n * will return\n *\n * {right: 'right', wrong: {value: 'wrong', errors: ['error message']}}\n *\n * This is suitable for a structural diff with the actual value, where only\n * problem fields will be mismatches\n */\nexport function intertwingle(actual: any, problems: Problems, path: Path = []): any {\n  const myProblems = problems.problems\n    .filter(p => pathsEq(path, p.path))\n    .map(p => p.message);\n\n  const intertwingled = intertwingledValue(actual, problems, path);\n\n  return myProblems.length === 0\n    ? intertwingled\n    : myProblems.length === 1\n      ? myProblems[0]\n      : myProblems;\n}\n\nexport class ValidationError extends Error {\n  public readonly actual?: any;\n  public readonly expected?: any;\n\n  constructor(actual: any,\n              public readonly problems: Problems,\n              {\n                message = 'Validation failed',\n                leakActualValuesInError = false,\n              }: Partial<ValidationErrorOpts> = {}\n  ) {\n    super(`${message}:\\n${problems}${leakActualValuesInError ? `\\nactual:${JSON.stringify(actual, null, 2)}\\n` : ''}`);\n    if (leakActualValuesInError) {\n      this.actual = actual;\n      this.expected = intertwingle(actual, problems, []);\n      showDiff: true\n    }\n  }\n\n\n}","import {\n  Behaviour,\n  conform,\n  isError,\n  MissingItemBehaviour,\n  Pattern,\n  patternItemToSchema,\n  Schema,\n  UnexpectedItemBehaviour,\n  usingBehaviour,\n  ValidationError, ValidationOpts\n} from \"./impl\";\n\nexport type Likeable = Array<any> | object;\nconst DEFAULT_BEHAVIOUR: Behaviour = {\n  missing: MissingItemBehaviour.PROBLEM,\n  unexpected: UnexpectedItemBehaviour.IGNORE,\n  leakActualValuesInError: true,\n};\n\n/**\n * Conforms actual to the schema, or to the expected pattern using object();\n *\n * Returns the conformed value if successful.\n *\n * Otherwise throws an assertion Error, with actual, expected and showDiff, compatible with AssertionError, as used by\n * mocha, WebStorm, etc.\n *\n * The 'expected' field on the error will produce a usable diff with the actual value. See documentation on\n * intertwingle() for the shape of 'expected' on the error.\n */\nexport function like<T extends Likeable>(\n  actual: any,\n  expected: Pattern<T> | Schema<any, T>,\n  opts: Partial<ValidationOpts> = {}\n): T {\n  const behaviour = Object.assign({}, DEFAULT_BEHAVIOUR, opts);\n  const schema: Schema = patternItemToSchema(expected as any);\n\n  const result = usingBehaviour(\n    behaviour,\n    () => conform(schema, actual));\n\n  if (isError(result)) {\n    throw new ValidationError(\n      actual,\n      result,\n      {\n        leakActualValuesInError: behaviour.leakActualValuesInError,\n        message: opts.message\n      });\n  }\n\n  return result as T;\n}","import {conform} from \"../helpers\"\nimport {\n  BaseSchema,\n  BehaviourSchema,\n  failure,\n  isSchema,\n  isSuccess,\n  ObjectSchema,\n  Pattern,\n  Problems,\n  Schema,\n  UnexpectedItemBehaviour,\n  ValidationResult\n} from \"../impl\";\nimport {subSchemaJson} from \"../jsonSchema\";\n\nexport class ConditionalSchema<IN extends object, OUT, MATCH = any> extends BaseSchema<IN, OUT> {\n  constructor(\n    private readonly matches: [Schema<IN>, Schema<IN, OUT>][]) {\n    super();\n  }\n\n  conform(value: IN): ValidationResult<OUT> {\n    let problems = failure('could not match any case');\n    for (const [case_, schema] of this.matches) {\n      const matchResult = conform(case_, value);\n      if (isSuccess(matchResult))\n        return conform(schema, value);\n      else\n        problems = problems.merge(matchResult);\n    }\n    return problems as Problems;\n  }\n\n  case<OTHER extends object>(case_: Pattern<OTHER> | Schema<IN, any>, schema: Schema<IN, OTHER>): ConditionalSchema<IN, OUT | OTHER> {\n    const caseSchema = isSchema(case_)\n      ? case_\n      : new BehaviourSchema({unexpected: UnexpectedItemBehaviour.IGNORE}, new ObjectSchema(case_));\n\n    return new ConditionalSchema<IN, OUT | OTHER>(\n      [...this.matches, [caseSchema, schema]]);\n  }\n\n  toJSON(toJson?: (s: Schema) => any): any {\n    if (this.matches.length === 0)\n      return false;\n\n    function subs(schema:Schema):any{\n      const result = subSchemaJson(schema, toJson);\n      delete result['additionalProperties'];\n      delete result['required'];\n      delete result['type'];\n      return result;\n    }\n    return this.matches\n      .reverse()\n      .reduce((result, [condition, schema]) => {\n        return {\n          if: subs(condition),\n          then: subSchemaJson(schema, toJson),\n          ...(result ? {else: result} : {})\n        };\n      }, undefined);\n  }\n}\n\n","import {\n  conform,\n  failure,\n  hasSchema,\n  isSchema,\n  ObjectSchema,\n  Problems,\n  Schema,\n  schemaOf,\n  schematizeEntries,\n  StrictPattern,\n  suspendValidation,\n  usingBehaviour,\n  ValidationError,\n  ValidationOpts,\n  ValidationResult\n} from \"./impl\";\nimport {BaseSchema} from \"./impl/core\";\nimport {Constructor, isPrimitive} from \"./impl/util/types\";\n\nexport function data<C extends Constructor>(c: C): C {\n  // suspendValidation is required to allow calling parent constructor\n  const objectWithDefaults = suspendValidation(() => new c() as StrictPattern<C>);\n\n  for (const [k, v] of Object.entries(objectWithDefaults)) {\n    if (!(isSchema(v) || isPrimitive(v)))\n      throw new Error(`Field '${k}' on ${c.name} is neither a schema nor a primitive value`);\n  }\n\n  const schema = new ObjectSchema<C>(schematizeEntries(objectWithDefaults));\n  return hasSchema(schema)(c);\n}\n\nexport function intersect<A extends object, B extends object>\n(a: Constructor<A>, b: Constructor<B>): Constructor<A & B> {\n\n  const schema: ObjectSchema<A & B> = schemaOf(a).intersect(schemaOf(b));\n\n  @hasSchema(schema as any)\n  class Intersection {\n  }\n\n  for (let id in a.prototype) {\n    (<any>Intersection.prototype)[id] = (<any>a.prototype)[id];\n  }\n  for (let id in b.prototype) {\n    if (!Intersection.prototype.hasOwnProperty(id)) {\n      (<any>Intersection.prototype)[id] = (<any>b.prototype)[id];\n    }\n  }\n  return Intersection as any as Constructor<A & B>;\n}\n\nexport function makeInstance<T>(c: Constructor<T>, obj: object): T {\n  return Object.assign(Object.create(c.prototype), obj);\n}\n\nexport function conformAs<T extends object>(c: Constructor<T>, obj: object): ValidationResult<T> {\n  const result = conform(schemaOf(c), obj);\n  if (result instanceof Problems)\n    return result;\n  return makeInstance(c, result);\n}\n\n\nexport function build<T extends object>(\n  c: Constructor<T>,\n  values: any,\n  opts: Partial<ValidationOpts> = {}): T {\n  const conformed = usingBehaviour(opts, () => conformAs(c, values));\n  if (conformed instanceof Problems) {\n    throw new ValidationError(values, conformed, opts);\n  }\n  return conformed;\n}\n\n/**\n * Call this instead of build() when constructing data instances\n * by specifying fields in code. The compiler will complain if\n * fields are missing.\n *\n * `build(A, {})` will NOT cause the compiler to complain,\n * even if `{}` is missing fields `A` requires.\n *\n * `construct(A, {})` WILL cause the compiler to complain if\n * `{}` is missing fields `A` requires.\n */\nexport function construct<T extends object>(\n  c: Constructor<T>,\n  value: T,\n  opts: Partial<ValidationOpts> = {}): T {\n  return build(c, value, opts);\n}\n\nexport class DataSchema<T extends object> extends BaseSchema<any, T> {\n  public readonly subSchema: Readonly<ObjectSchema<T>>;\n\n  constructor(private readonly c: Constructor<T>) {\n    super();\n    this.subSchema = schemaOf(c);\n  }\n\n  conform(value: any): Problems | T {\n    if (value instanceof this.c) return value;\n    if (typeof value !== 'object') return failure(`Expected an object but got a ${typeof value}`);\n\n    try {\n      return build(this.c, value)\n        ;\n    } catch (e) {\n      if (e instanceof ValidationError) {\n        return e.problems;\n      }\n      throw e;\n    }\n  }\n\n  toJSON(toJson?: (s: Schema) => any): any {\n    return this.subSchema.toJSON(toJson);\n  }\n}\n","export function identity<T>(t: T): T {\n  return t;\n}","import {DataSchema} from \"./data\";\nimport {\n  ArrayOfSchema,\n  Behaviour,\n  BehaviourSchema,\n  BooleanSchema,\n  ConditionalSchema,\n  DefaultValueSchema,\n  DeferredSchema,\n  DelegatingSchema,\n  detectDiscriminator,\n  DiscriminatedUnionSchema,\n  E164PhoneNumberSchema,\n  EnumValueSchema,\n  EqualsSchema,\n  failure,\n  InSchema,\n  IsInstanceSchema,\n  IsoUtcDateSchema,\n  isSchema,\n  IsURLOptions,\n  LensBehaviour,\n  LensSchema,\n  LookupSchema,\n  MapSchema,\n  MissingItemBehaviour,\n  NumberSchema,\n  ObjectSchema,\n  ObjOfSchema,\n  Opts,\n  OrSchema,\n  OverrideSchema,\n  Pattern,\n  Problems,\n  RegExpSchema,\n  Schema,\n  schemaOf,\n  SchemaOverrides,\n  schematizeEntries,\n  SelectSchema,\n  SetOfSchema,\n  StrictPattern,\n  StringSchema,\n  TagSchemaAsOptional,\n  TimeExpectation,\n  TupleSchema,\n  UnexpectedItemBehaviour,\n  UniqueSchema,\n  UrlSchema,\n  UuidSchema,\n} from \"./impl\";\nimport {identity} from \"./impl/util/functions\";\nimport {Constructor} from \"./impl/util/types\";\n\nexport function __<IN, OUT>(s: Schema<IN, OUT>): OUT {\n  return s.__();\n}\n\n/**\n * Marks a field as optional. MUST be used as the outer schema:\n *\n * Ok:\n *\n * @data\n * class Cat {\n *   name?:string =__(opt(isstring().or(isnumber())))\n * }\n *\n * Not ok:\n *\n * @data\n * class Cat {\n *   name?:string =__(opt(isstring()).or(isnumber())\n * }\n */\nexport function opt<IN, OUT>(s: Schema<any, OUT>): Schema<any, OUT | undefined> {\n  return new TagSchemaAsOptional(s);\n}\n\nexport function isdata<T extends object>(constructor: Constructor<T>): Schema<any, T> {\n  return new DataSchema(constructor);\n}\n\nexport function partial<T extends object>(type: Constructor<T>): Schema<any, Partial<T>> {\n  return onMissing(schemaOf(type), MissingItemBehaviour.IGNORE);\n}\n\nexport function onMissing<IN, OUT>(schema: Schema<IN, OUT>, behaviour: MissingItemBehaviour): Schema<IN, OUT> {\n  return withBehaviour(schema, {missing: behaviour});\n}\n\nexport function onUnexpected<IN, OUT>(schema: Schema<IN, OUT>, behaviour: UnexpectedItemBehaviour): Schema<IN, OUT> {\n  return withBehaviour(schema, {unexpected: behaviour});\n}\n\nexport function withBehaviour<IN, OUT>(schema: Schema<IN, OUT>, behaviour: Partial<Behaviour>): Schema<IN, OUT> {\n  return new BehaviourSchema(behaviour, schema);\n}\n\nfunction deepNullablePattern(fieldSchemaArray: [string, Schema][]): Pattern<any> {\n  const nullableFieldsObjectPattern = {};\n  for (const [k, s] of fieldSchemaArray) {\n    if (\"fieldSchemaArray\" in s) { // TODO testing if schema represents an object should be different\n      const nullableFieldsObjectSchema = new ObjectSchema(deepNullablePattern((s as ObjectSchema<any>).fieldSchemaArray));\n      nullableFieldsObjectPattern[k] = new OrSchema([nullableFieldsObjectSchema, isnull()]);\n    } else {\n      nullableFieldsObjectPattern[k] = new OrSchema([s, isnull()]);\n    }\n  }\n  return nullableFieldsObjectPattern\n}\n\nexport function deepNullable<T extends object>(type: Constructor<T>): Schema<any, DeepNullable<T>> {\n  const objectSchema: ObjectSchema<T> = schemaOf(type);\n\n  return new ObjectSchema(deepNullablePattern(objectSchema.fieldSchemaArray));\n}\n\nexport type Nullable<T> = T | null\n\nexport type DeepNullable<T extends object> = {\n  [P in keyof T]: T[P] extends object ? DeepNullable<T[P]> : Nullable<T[P]>;\n}\n\nexport function eq<T>(value: T): Schema<any, T> {\n  return new EqualsSchema(value);\n}\n\nexport function gt(value: number): Schema<any, number> {\n  return new NumberSchema({exclusiveMinimum: value});\n}\n\nexport function lt(value: number): Schema<any, number> {\n  return new NumberSchema({exclusiveMaximum: value});\n}\n\nexport function gte(value: number): Schema<any, number> {\n  return new NumberSchema({minimum: value});\n}\n\nexport function lte(value: number): Schema<any, number> {\n  return new NumberSchema({maximum: value});\n}\n\nexport interface RangeOpts {\n  lowerInclusive: boolean;\n  upperInclusive: boolean;\n}\n\nexport function range(\n  from: number,\n  to: number,\n  {lowerInclusive = true, upperInclusive = false}: Partial<RangeOpts> = {})\n  : Schema<any, number> {\n\n  const min: Opts = lowerInclusive\n    ? {minimum: from}\n    : {exclusiveMinimum: from};\n\n  const max: Opts = upperInclusive\n    ? {maximum: to}\n    : {exclusiveMaximum: to};\n\n  return isnumber({...min, ...max});\n}\n\nexport function isnull(): Schema<any, null> {\n  return eq(null);\n}\n\nexport function isobject(): Schema<any, object> {\n  return withBehaviour(new ObjectSchema({}), {unexpected: UnexpectedItemBehaviour.IGNORE});\n}\n\nexport function isundefined(): Schema<any, undefined> {\n  return eq(undefined);\n}\n\nexport function isany(): Schema<any, any> {\n  return schema((x) => x, () => true);\n}\n\nexport function fail(problems: Problems = failure('always fails')): Schema<any, any> {\n  return schema(() => problems, () => false);\n}\n\nexport function arrayof<T>(schema: Schema<any, T>): Schema<any, T[]> {\n  return new ArrayOfSchema(schema);\n}\n\nexport function setof<T>(schema: Schema<any, T>): Schema<any, Set<T>> {\n  return new SetOfSchema(schema);\n}\n\nexport function enumvalue<T extends object>(e: T): Schema<any, T[keyof T]> {\n  return new EnumValueSchema(e);\n}\n\nexport function enumkey<T extends object>(e: T): Schema<any, T[keyof T]> {\n  const stringKeysOnly = {};\n  for (let [k, v] of Object.entries(e)) {\n    if (isNaN(Number(k)))\n      stringKeysOnly[k] = v;\n  }\n\n  return lookup(stringKeysOnly);\n}\n\nexport function lookup<T extends object>(e: T): Schema<any, T[keyof T]> {\n  return new LookupSchema(e);\n}\n\nexport function discriminated<T extends object>(...ctors: Constructor<T>[]): Schema<any, T> {\n  return discriminatedBy(detectDiscriminator(ctors), ...ctors);\n}\n\nexport function discriminatedBy<T extends object>(discriminator: keyof T,\n                                                  ...ctors: Constructor<T>[]): Schema<any, T> {\n  return new DiscriminatedUnionSchema<T>(ctors, discriminator);\n}\n\nexport function isstring(): Schema<any, string> {\n  return new StringSchema();\n}\n\nexport function isinstance<T>(c: Constructor<T>): Schema<any, T> {\n  return new IsInstanceSchema(c);\n}\n\nexport function matches(r: RegExp): Schema<any, string> {\n  return new RegExpSchema(r);\n}\n\nexport function conditional(): ConditionalSchema<any, any> {\n  return new ConditionalSchema([]);\n}\n\nexport function isboolean(): Schema<any, boolean> {\n  return new BooleanSchema();\n}\n\nexport function isIn<T extends number | string | null>(...values: T[]): Schema<any, T> {\n  return new InSchema<T>(values);\n}\n\nexport function isurl(opts?: IsURLOptions): Schema<any, string> {\n  return new UrlSchema(opts || {});\n}\n\nexport function isuuid(): Schema<any, string> {\n  return new UuidSchema();\n}\n\nexport function isnumber(opts: Opts = {}): Schema<any, number> {\n  return new NumberSchema(opts);\n}\n\nconst DATE_TIME = new IsoUtcDateSchema(TimeExpectation.ALWAYS);\n\nexport function isoUtcDateTime(): Schema<any, Date> {\n  return DATE_TIME;\n}\n\nconst DATE = new IsoUtcDateSchema(TimeExpectation.NEVER);\n\nexport function isoDateOnly(): Schema<any, Date> {\n  return DATE;\n}\n\n/**\n * E.164 phone number normaliser\n * if no default country is passed, it validates number depending on coutry calling code (has to begin with '+')\n */\nexport function e164PhoneNumber(defaultCountryIso3166?: string): Schema<any, string> {\n  return new E164PhoneNumberSchema(defaultCountryIso3166);\n}\n\nexport function object<T extends object>(\n  pattern: StrictPattern<T>\n): Schema<any, T> {\n  return new ObjectSchema<T>(pattern);\n}\n\nexport function deepPartial<T extends object>(\n  pattern: Pattern<T>): Schema<any, T> {\n  return onUnexpected<any, T>(new ObjectSchema<T>(pattern), UnexpectedItemBehaviour.IGNORE);\n}\n\n/**\n * An object where all values conform to schema\n */\nexport function objof<T>(schema: Schema<any, T>): Schema<any, { [k: string]: T }> {\n  return new ObjOfSchema(schema);\n}\n\nexport function map<K, V>(entryPattern: Pattern<{}> | Map<K, Schema<any, V>>): Schema<any, Map<K, V>> {\n  const subSchema = new ObjectSchema<any>(entryPattern instanceof Map\n    ? schematizeEntries(entryPattern)\n    : entryPattern);\n  return new MapSchema<K, V>(subSchema);\n}\n\nexport function tuple<A>(a: Schema<any, A>): Schema<any, [A]>;\n\nexport function tuple<A, B>(a: Schema<any, A>, b: Schema<any, B>): Schema<any, [A, B]>;\n\nexport function tuple<A, B, C>(a: Schema<any, A>, b: Schema<any, B>, c: Schema<any, C>): Schema<any, [A, B, C]>;\n\nexport function tuple<A, B, C, D>(a: Schema<any, A>, b: Schema<any, B>, c: Schema<any, C>, d: Schema<any, D>): Schema<any, [A, B, C, D]> ;\n\nexport function tuple<A, B, C, D, E>(a: Schema<any, A>, b: Schema<any, B>, c: Schema<any, C>, d: Schema<any, D>, e: Schema<any, E>): Schema<any, [A, B, C, D, E]>;\n\nexport function tuple<T extends any[]>(...s: Schema[]): Schema<any, T> ;\n\nexport function tuple<T extends any[]>(...s: Schema[]): Schema<any, T> {\n\n  return new TupleSchema(s);\n}\n\nexport function schema<IN, OUT>(\n  conform: (value: IN) => Problems | OUT,\n  toJSON?: () => any): Schema<IN, OUT> {\n  return new DelegatingSchema<IN, OUT>(conform, toJSON);\n}\n\n\nexport function predicate<T>(predicate: (value: T) => boolean,\n                             failureMessage?: ((value: any) => string) | string): Schema<T, T> {\n\n  function buildPredicateMessageFunction(message: ((value: any) => string) | string | undefined, predicate: (x: any) => boolean): (value: any) => string {\n    switch (typeof message) {\n      case 'string':\n        return () => message as string;\n      case 'function':\n        return message as () => string;\n      case 'undefined':\n        return () => predicate.toString();\n      default:\n        throw new Error(`Not a valid message ${message}`);\n    }\n  }\n\n  const messageFn = buildPredicateMessageFunction(failureMessage, predicate);\n  return schema(\n    (x) => predicate(x) === true ? x : failure(messageFn(x)))\n}\n\n/**\n * Note that when using `defer()` to recursively nest schemas, by default `toJSON()` will\n * stack overflow.\n *\n * You need to make sure that all schemas used in recursion are in the definitions\n * when calling jsonSchema(), so that they get replaced by $refs.\n *\n * ```\n * const node = object({children: arrayof(defer(() =>node))});\n *\n * // this will overflow:\n * node.toJSON();\n *\n * // this will not:\n * jsonSchema({definitions:{node: node}};\n * ```\n */\nexport function defer<IN, OUT>(factory: () => Schema<IN, OUT>): Schema<IN, OUT> {\n  return new DeferredSchema(factory);\n}\n\nexport {SchemaOverrides} from \"./impl/override\";\n\nexport function override<IN, OUT>(s: Schema<IN, OUT>, o: SchemaOverrides<IN, OUT>) {\n  return new OverrideSchema(s, o);\n}\n\nexport function unique<T>(): Schema<any, T[]> {\n  return uniqueBy(identity);\n}\n\nexport function uniqueBy<T, V = any>(fn: (t: T) => V): Schema<T[], T[]> {\n  return new UniqueSchema<T, V>(fn);\n}\n\nexport function select<T>(path: string[], s: Schema<any, T>): Schema<any, T> {\n  return new SelectSchema(path, s);\n}\n\nexport function anyOf<T>(...items: (T | Schema<any, T>)[]): Schema<any, T> {\n  const result: Schema<any, T> | undefined = items.reduce(\n    (result: Schema<any, T> | undefined, item: Schema<any, T> | T): Schema<any, T> => {\n      const schema = isSchema(item) ? item : eq(item);\n      return result ? result.or(schema) : schema;\n    }, undefined);\n  return result || fail(failure('oneOf() with no values provided'));\n}\n\n\nexport {LensBehaviour} from './impl/lens'\n\n/**\n * Expects an object. Conforms value at path using schema, and returns the outer object.\n *\n * lens([\"a\", \"b\"], eq(\"valid\")).conform({a:{b:\"valid\"}}) returns {a:{b:\"valid\"}}\n */\nexport function lens<T, U>(path: string[], s: Schema<any, U>): Schema<any, T> {\n  return new LensSchema(path, s);\n}\n\nexport function defaultValue<T>(value: () => T, schema: Schema<any, T>): Schema<any, T> {\n  return new DefaultValueSchema(value, schema)\n}"],"names":["UnexpectedItemBehaviour","MissingItemBehaviour","merge","TimeExpectation","LensBehaviour"],"mappings":"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"}